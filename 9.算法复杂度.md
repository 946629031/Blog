# 算法复杂度
> JS编码中 常见的算法复杂度可以分为：
> 常数级，线性级，平方级，对数级，线性对数级，5种等级的

|复杂度符号	| 中文等级	| 核心特征	| 性能排序（从优到差）
|---|---|---|---|
|O(1)	| 常数级	| 执行步骤固定，与 n 无关	| 1（最优）|
|O(log n)	| 对数级	| 每次操作砍掉一半数据	| 2|
|O(n)	| 线性级	| 执行步骤随 n 正比例增长	| 3|
|O(n log n)	| 线性对数级	| n × log n（拆分 + 遍历）	| 4|
|O(n²)	| 平方级	| 嵌套循环，步骤随 n² 增长	| 5（最差）|
|O(2ⁿ)|指数级|每增加 1 个 n，执行步骤翻倍（2 的 n 次方）；典型特征是 “递归拆分出 2 个分支”|6（性能极差）|
|O(n!)|阶乘级|执行步骤是 n 的阶乘（n×(n-1)×(n-2)×…×1）；典型特征是 “全排列 / 所有组合枚举”|7（性能极极差）|

日常开发要避开 平方级 和以上，遇到 O (2ⁿ) 优先优化。

![](https://img2023.cnblogs.com/blog/3234957/202307/3234957-20230710171650000-317271523.png)
![](https://i-blog.csdnimg.cn/blog_migrate/91a989bcdafb68398ef0db60c1253a9b.png)


## “n 每增加 1” 的视角，直观看到不同复杂度的增长差异
| n值 | O(1) | O(log₂n) | O(n) | O(n log₂n) | O(n²) | O(2ⁿ) | O(n!) |
|-----|----------------|--------------------|----------------|--------------------------|-----------------|-----------------|-----------------|
|     | 常数级           | 对数级            |线性级           |线性对数级                 | 平方级          | 指数级           | 阶乘级          |
|     | 不涨              | 微涨            |稳涨              |缓涨                 | 快涨              | 翻倍涨               | 爆炸涨         |
| 1   | 1              | 0（log₂1=0）| 1              | 0（1×0）| 1               | 2               | 1               |
| 2   | 1              | 1（log₂2=1）| 2              | 2（2×1）| 4               | 4               | 2               |
| 3   | 1              | 1.58（≈2）| 3              | 4.76（≈5）| 9               | 8               | 6               |
| 4   | 1              | 2（log₂4=2）| 4              | 8（4×2）| 16              | 16              | 24              |
| 5   | 1              | 2.32（≈2）| 5              | 11.6（≈12）| 25              | 32              | 120             |
| 6   | 1              | 2.58（≈3）| 6              | 15.5（≈16）| 36              | 64              | 720             |
| 7   | 1              | 2.81（≈3）| 7              | 19.7（≈20）| 49              | 128             | 5040            |
| 8   | 1              | 3（log₂8=3）| 8              | 24（8×3）| 64              | 256             | 40320           |
| 9   | 1              | 3.17（≈3）| 9              | 28.5（≈29）| 81              | 512             | 362880          |
| 10  | 1              | 3.32（≈3）| 10             | 33.2（≈33）| 100             | 1024            | 3628800         |



<br><br><br><br><br><br><br><br>




# JavaScript 常见算法对应的复杂度汇总
## 一、排序算法（JS最常用）
| 算法名称       | 时间复杂度（平均/最坏） | 空间复杂度 | 核心特征 & JS场景                          |
|----------------|-------------------------|------------|--------------------------------------------|
| 冒泡排序       | O(n²) / O(n²)           | O(1)       | 双层嵌套循环，原地排序；JS新手入门排序      |
| 选择排序       | O(n²) / O(n²)           | O(1)       | 双层循环选最值，原地排序；性能略优于冒泡    |
| 插入排序       | O(n²) / O(n²)           | O(1)       | 适合小规模/近乎有序数据；部分浏览器排序优化 |
| 快速排序       | O(n log n) / O(n²)      | O(log n)   | JS数组`sort`底层（V8引擎）；分治思想       |
| 归并排序       | O(n log n) / O(n log n) | O(n)       | 稳定排序；适合大数据量，空间换时间          |
| 内置`Array.sort()` | O(n log n) / O(n log n) | O(log n) | V8引擎：数组长度≤22用插入排序，>22用快速排序 |

## 二、查找算法（JS高频）
| 算法名称       | 时间复杂度（平均/最坏） | 空间复杂度 | 核心特征 & JS场景                          |
|----------------|-------------------------|------------|--------------------------------------------|
| 线性查找（遍历）| O(n) / O(n)             | O(1)       | 遍历数组/字符串；`Array.indexOf()`/`find()` |
| 二分查找       | O(log n) / O(log n)     | O(1)       | 仅有序数组可用；`Array.includes()`优化版    |
| 哈希查找（对象/Map） | O(1) / O(n)       | O(n)       | JS中`obj[key]`/`map.get()`；最坏情况哈希冲突 |

## 三、递归/动态规划算法（算法题高频）
| 算法场景               | 时间复杂度 | 空间复杂度 | 核心特征 & JS示例                          |
|------------------------|------------|------------|--------------------------------------------|
| 未优化斐波那契递归     | O(2ⁿ)      | O(n)       | 重复计算，性能极差；`fib(n)=fib(n-1)+fib(n-2)` |
| 记忆化斐波那契         | O(n)       | O(n)       | 缓存已计算结果；用对象/数组存中间值        |
| 动态规划斐波那契       | O(n)       | O(1)       | 迭代实现，原地更新；最优解                 |
| 汉诺塔问题             | O(2ⁿ)      | O(n)       | 递归拆分2分支；指数级增长                  |
| 爬楼梯问题（动态规划）| O(n)       | O(1)       | 状态转移方程：`dp[n]=dp[n-1]+dp[n-2]`      |

## 四、数组/字符串常用操作（日常开发高频）
| 操作/方法               | 时间复杂度 | 空间复杂度 | 核心说明                                  |
|-------------------------|------------|------------|-------------------------------------------|
| `arr.push()`/`arr.pop()` | O(1)       | O(1)       | 数组尾部操作，无需移动元素                |
| `arr.shift()`/`arr.unshift()` | O(n)   | O(1)       | 数组头部操作，需移动所有元素              |
| `arr.slice()`/`arr.concat()` | O(k)   | O(k)       | k为返回数组长度；复制新数组               |
| `arr.splice()`          | O(n)       | O(1)       | 增删数组元素，需移动后续元素              |
| `arr.forEach()`/`map()` | O(n)       | O(1)/O(n)  | `map`返回新数组，空间O(n)；`forEach` O(1) |
| `str.indexOf()`/`includes()` | O(n)   | O(1)       | 线性遍历字符串                            |
| `Object.keys()`/`Object.values()` | O(n) | O(n) | n为对象属性数量；返回新数组               |
| `Set.has()`/`Map.has()` | O(1)       | O(n)       | 哈希表实现，查找效率远高于数组遍历        |

## 五、图/树相关算法（进阶）
| 算法名称               | 时间复杂度 | 空间复杂度 | 核心特征                                  |
|------------------------|------------|------------|-------------------------------------------|
| 二叉树前/中/后序遍历   | O(n)       | O(h)       | h为树的高度；递归版空间O(h)，迭代版O(1)   |
| 二叉树层序遍历（BFS）| O(n)       | O(n)       | 队列实现；最坏情况存储一层所有节点        |
| 深度优先搜索（DFS）| O(n)       | O(h)       | 递归/栈实现；h为递归深度                  |
| 广度优先搜索（BFS）| O(n)       | O(n)       | 队列实现；图/树的遍历                     |

## 总结
### 1. 核心规律
- 双层嵌套循环 → 大概率O(n²)（如冒泡/选择排序）；
- 分治/二分 → O(log n) 或 O(n log n)（如快排/二分查找）；
- 哈希表（Object/Map/Set）查找 → 平均O(1)（JS开发优先用）；
- 未优化递归 → 易出现O(2ⁿ)（需用记忆化/动态规划优化）。

### 2. 实用建议
- 日常排序优先用`Array.sort()`（O(n log n)），避免手写O(n²)排序；
- 数组查找优先用`Map/Set`（O(1)），替代线性遍历（O(n)）；
- 数组增删优先用尾部操作（`push/pop` O(1)），避免头部操作（`shift/unshift` O(n)）。

### 3. 记忆技巧
把“算法类型-复杂度-JS方法”绑定记忆（如：快排=O(n log n)=`Array.sort()`；二分查找=O(log n)=有序数组查找；哈希查找=O(1)=`Map.get()`）。




<br><br><br><br><br>


# JS 日常代码写法的时间复杂度速览

假设输入规模为 n，给出代码示例 + 复杂度 + 核心结论。

## 一、循环相关（日常写得最多）

### 1) 单层 for 循环（包括 forEach / map / filter）
- 代码示例：

```js
// 单层for循环
let sum = 0;
for (let i = 0; i < arr.length; i++) { // 循环次数 = 数组长度n
  sum += arr[i];
}

// 等价的forEach（底层也是单层遍历）
arr.forEach(item => {
  console.log(item);
});
```

- 复杂度：时间复杂度 O (n)（线性级），空间复杂度 O (1)
- 核心结论：只要是 “把数组 / 字符串遍历一遍” 的单层循环，不管是原生 for、forEach、map 还是 filter，时间复杂度都是 O (n)（n 为数据长度）。


### 2. 双层嵌套 for 循环（for 套 for）
代码示例
```js
// 双层嵌套循环（比如找两数之和的暴力解法）
function findTwoSum(arr, target) {
  for (let i = 0; i < arr.length; i++) { // 外层n次
    for (let j = i + 1; j < arr.length; j++) { // 内层最多n次
      if (arr[i] + arr[j] === target) {
        return [i, j];
      }
    }
  }
}
```

- 复杂度：时间复杂度 O (n²)（平方级），空间复杂度 O (1)
- 核心结论：只要是 “循环里套循环”，且两层循环都依赖同一个数据长度 n，时间复杂度就是 O (n²)（比如冒泡排序、选择排序的核心逻辑）。

### 3. 两个独立的单层 for 循环（不是嵌套）
代码示例：
```js
// 第一个单层循环
let sum1 = 0;
for (let i = 0; i < arr.length; i++) {
  sum1 += arr[i];
}

// 第二个独立的单层循环
let sum2 = 0;
for (let j = 0; j < arr.length; j++) {
  sum2 += arr[j] * 2;
}
```

- 复杂度：时间复杂度 O (n)（不是 O (2n)，复杂度忽略常数），空间复杂度 O (1)
- 核心结论：多个独立的单层循环，复杂度还是 O (n)（因为复杂度只看 “最高阶项”，常数会被忽略）。


### 4. 二分查找的循环（砍半逻辑）
代码示例
```js
// 有序数组找元素（二分循环）
function binarySearch(arr, target) {
  let left = 0, right = arr.length - 1;
  while (left <= right) { // 每次循环砍掉一半数据
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) return mid;
    else if (arr[mid] < target) left = mid + 1;
    else right = mid - 1;
  }
  return -1;
}
```

- 复杂度：时间复杂度 O (log n)（对数级），空间复杂度 O (1)
- 核心结论：只要循环里有 “折半” 逻辑（每次排除一半数据），不管是 while 还是 for，时间复杂度都是 O (log n)。

  
## 二、数组操作（日常开发高频）
### 1. 数组尾部操作：push/pop
代码示例：
```js
arr.push(10); // 尾部加元素
arr.pop(); // 尾部删元素
```
复杂度：时间复杂度 O (1)（常数级），空间复杂度 O (1)
核心结论：数组尾部操作不需要移动其他元素，一步到位，永远是 O (1)。

### 2. 数组头部操作：shift/unshift
代码示例：
```js
arr.shift(); // 头部删元素
arr.unshift(10); // 头部加元素
```
复杂度：时间复杂度 O (n)（线性级），空间复杂度 O (1)
核心结论：头部操作需要移动数组所有元素（比如删第一个元素，后面的元素都要往前挪一位），所以是 O (n)。

### 3. 数组切片 / 拼接：slice/concat
代码示例：
```js
const newArr1 = arr.slice(0, 5); // 截取前5个元素
const newArr2 = arr.concat([6,7,8]); // 拼接新数组
```
复杂度：时间复杂度 O (k)（k 为返回的新数组长度），空间复杂度 O (k)
核心结论：这类操作需要复制新数组，复杂度和 “复制的元素数量” 相关，日常可简化记为 O (n)（n 为原数组长度）。

### 4. 数组 splice 操作
代码示例：
```js
arr.splice(2, 1); // 从索引2删1个元素
arr.splice(2, 0, 10); // 从索引2插入元素10
```
复杂度：时间复杂度 O (n)（线性级），空间复杂度 O (1)
核心结论：splice 会移动操作位置之后的所有元素，所以是 O (n)（哪怕只删 / 插 1 个元素）。

## 三、对象 / Map/Set 操作（日常优化常用）
1. 对象属性访问 / 赋值：obj.key
```js
const obj = { name: '张三' };
console.log(obj.name); // 访问属性
obj.age = 20; // 赋值属性
```

复杂度：时间复杂度 O (1)（常数级），空间复杂度 O (1)
核心结论：对象的属性操作是哈希表底层实现，一步到位，永远是 O (1)。

### 2. Map/Set 的增删查：get/set/has
```js
const map = new Map();
map.set('name', '张三'); // 赋值
console.log(map.get('name')); // 查找
console.log(map.has('name')); // 判断存在

const set = new Set([1,2,3]);
set.has(2); // 判断存在
```
复杂度：时间复杂度 O (1)（平均）/ O (n)（最坏，哈希冲突），空间复杂度 O (1)
核心结论：日常开发中可默认记为 O (1)，这也是为什么用 Map/Set 替代数组遍历查找（O (n)）能优化性能。

## 四、字符串操作（日常处理常用）
### 1. 字符串遍历：for 循环 /charAt
代码示例：
```js
let str = 'hello world';
for (let i = 0; i < str.length; i++) {
  console.log(str.charAt(i));
}
```
复杂度：时间复杂度 O (n)（线性级），空间复杂度 O (1)
核心结论：字符串遍历和数组遍历一样，是 O (n)。

### 2. 字符串拼接：+ /concat
代码示例：
```js
let str1 = 'hello';
let str2 = 'world';
let res = str1 + ' ' + str2; // 拼接
```

### 字符串拼接复杂度说明
复杂度：时间复杂度 O(n)（n 为拼接后总长度），空间复杂度 O(n)
核心结论：字符串是不可变的，拼接本质是创建新字符串，所以是 O(n)。

### 总结
#### 核心对应关系：
- 单层循环 / 数组遍历 → O(n)；
- 嵌套循环 → O(n²)；
- 折半循环（二分）→ O(log n)；
- 数组 / 对象 / Map 的直接操作（push/pop/obj.key）→ O(1)；
- 数组头部操作 / 拼接 / splice → O(n)。

#### 实用优化技巧：
- 用 Map/Set（O(1)）替代嵌套循环（O(n²)）解决查找问题；
- 用数组尾部操作（O(1)）替代头部操作（O(n)）；
- 避免不必要的嵌套循环，优先拆成独立单层循环（还是 O(n)）。

#### 记忆口诀：
「单层 n、嵌套方、折半 log、直接操作就是 1」（“方” 指平方级 O(n²)，“1” 指 O(1)）。
