# 算法复杂度
> JS编码中 常见的算法复杂度可以分为：
> 常数级，线性级，平方级，对数级，线性对数级，5种等级的

|复杂度符号	| 中文等级	| 核心特征	| 性能排序（从优到差）
|---|---|---|---|
|O(1)	| 常数级	| 执行步骤固定，与 n 无关	| 1（最优）|
|O(log n)	| 对数级	| 每次操作砍掉一半数据	| 2|
|O(n)	| 线性级	| 执行步骤随 n 正比例增长	| 3|
|O(n log n)	| 线性对数级	| n × log n（拆分 + 遍历）	| 4|
|O(n²)	| 平方级	| 嵌套循环，步骤随 n² 增长	| 5（最差）|
|O(2ⁿ)|指数级|每增加 1 个 n，执行步骤翻倍（2 的 n 次方）；典型特征是 “递归拆分出 2 个分支”|6（性能极差）|
|O(n!)|阶乘级|执行步骤是 n 的阶乘（n×(n-1)×(n-2)×…×1）；典型特征是 “全排列 / 所有组合枚举”|7（性能极极差）|

日常开发要避开 平方级 和以上，遇到 O (2ⁿ) 优先优化。

![](https://img2023.cnblogs.com/blog/3234957/202307/3234957-20230710171650000-317271523.png)
![](https://i-blog.csdnimg.cn/blog_migrate/91a989bcdafb68398ef0db60c1253a9b.png)


## “n 每增加 1” 的视角，直观看到不同复杂度的增长差异
| n值 | O(1) | O(log₂n) | O(n) | O(n log₂n) | O(n²) | O(2ⁿ) | O(n!) |
|-----|----------------|--------------------|----------------|--------------------------|-----------------|-----------------|-----------------|
|     | 常数级           | 对数级            |线性级           |线性对数级                 | 平方级          | 指数级           | 阶乘级          |
|     | 不涨              | 微涨            |稳涨              |缓涨                 | 快涨              | 翻倍涨               | 爆炸涨         |
| 1   | 1              | 0（log₂1=0）| 1              | 0（1×0）| 1               | 2               | 1               |
| 2   | 1              | 1（log₂2=1）| 2              | 2（2×1）| 4               | 4               | 2               |
| 3   | 1              | 1.58（≈2）| 3              | 4.76（≈5）| 9               | 8               | 6               |
| 4   | 1              | 2（log₂4=2）| 4              | 8（4×2）| 16              | 16              | 24              |
| 5   | 1              | 2.32（≈2）| 5              | 11.6（≈12）| 25              | 32              | 120             |
| 6   | 1              | 2.58（≈3）| 6              | 15.5（≈16）| 36              | 64              | 720             |
| 7   | 1              | 2.81（≈3）| 7              | 19.7（≈20）| 49              | 128             | 5040            |
| 8   | 1              | 3（log₂8=3）| 8              | 24（8×3）| 64              | 256             | 40320           |
| 9   | 1              | 3.17（≈3）| 9              | 28.5（≈29）| 81              | 512             | 362880          |
| 10  | 1              | 3.32（≈3）| 10             | 33.2（≈33）| 100             | 1024            | 3628800         |



<br><br><br><br><br><br><br><br>




# JavaScript 常见算法对应的复杂度汇总
## 一、排序算法（JS最常用）
| 算法名称       | 时间复杂度（平均/最坏） | 空间复杂度 | 核心特征 & JS场景                          |
|----------------|-------------------------|------------|--------------------------------------------|
| 冒泡排序       | O(n²) / O(n²)           | O(1)       | 双层嵌套循环，原地排序；JS新手入门排序      |
| 选择排序       | O(n²) / O(n²)           | O(1)       | 双层循环选最值，原地排序；性能略优于冒泡    |
| 插入排序       | O(n²) / O(n²)           | O(1)       | 适合小规模/近乎有序数据；部分浏览器排序优化 |
| 快速排序       | O(n log n) / O(n²)      | O(log n)   | JS数组`sort`底层（V8引擎）；分治思想       |
| 归并排序       | O(n log n) / O(n log n) | O(n)       | 稳定排序；适合大数据量，空间换时间          |
| 内置`Array.sort()` | O(n log n) / O(n log n) | O(log n) | V8引擎：数组长度≤22用插入排序，>22用快速排序 |

## 二、查找算法（JS高频）
| 算法名称       | 时间复杂度（平均/最坏） | 空间复杂度 | 核心特征 & JS场景                          |
|----------------|-------------------------|------------|--------------------------------------------|
| 线性查找（遍历）| O(n) / O(n)             | O(1)       | 遍历数组/字符串；`Array.indexOf()`/`find()` |
| 二分查找       | O(log n) / O(log n)     | O(1)       | 仅有序数组可用；`Array.includes()`优化版    |
| 哈希查找（对象/Map） | O(1) / O(n)       | O(n)       | JS中`obj[key]`/`map.get()`；最坏情况哈希冲突 |

## 三、递归/动态规划算法（算法题高频）
| 算法场景               | 时间复杂度 | 空间复杂度 | 核心特征 & JS示例                          |
|------------------------|------------|------------|--------------------------------------------|
| 未优化斐波那契递归     | O(2ⁿ)      | O(n)       | 重复计算，性能极差；`fib(n)=fib(n-1)+fib(n-2)` |
| 记忆化斐波那契         | O(n)       | O(n)       | 缓存已计算结果；用对象/数组存中间值        |
| 动态规划斐波那契       | O(n)       | O(1)       | 迭代实现，原地更新；最优解                 |
| 汉诺塔问题             | O(2ⁿ)      | O(n)       | 递归拆分2分支；指数级增长                  |
| 爬楼梯问题（动态规划）| O(n)       | O(1)       | 状态转移方程：`dp[n]=dp[n-1]+dp[n-2]`      |

## 四、数组/字符串常用操作（日常开发高频）
| 操作/方法               | 时间复杂度 | 空间复杂度 | 核心说明                                  |
|-------------------------|------------|------------|-------------------------------------------|
| `arr.push()`/`arr.pop()` | O(1)       | O(1)       | 数组尾部操作，无需移动元素                |
| `arr.shift()`/`arr.unshift()` | O(n)   | O(1)       | 数组头部操作，需移动所有元素              |
| `arr.slice()`/`arr.concat()` | O(k)   | O(k)       | k为返回数组长度；复制新数组               |
| `arr.splice()`          | O(n)       | O(1)       | 增删数组元素，需移动后续元素              |
| `arr.forEach()`/`map()` | O(n)       | O(1)/O(n)  | `map`返回新数组，空间O(n)；`forEach` O(1) |
| `str.indexOf()`/`includes()` | O(n)   | O(1)       | 线性遍历字符串                            |
| `Object.keys()`/`Object.values()` | O(n) | O(n) | n为对象属性数量；返回新数组               |
| `Set.has()`/`Map.has()` | O(1)       | O(n)       | 哈希表实现，查找效率远高于数组遍历        |

## 五、图/树相关算法（进阶）
| 算法名称               | 时间复杂度 | 空间复杂度 | 核心特征                                  |
|------------------------|------------|------------|-------------------------------------------|
| 二叉树前/中/后序遍历   | O(n)       | O(h)       | h为树的高度；递归版空间O(h)，迭代版O(1)   |
| 二叉树层序遍历（BFS）| O(n)       | O(n)       | 队列实现；最坏情况存储一层所有节点        |
| 深度优先搜索（DFS）| O(n)       | O(h)       | 递归/栈实现；h为递归深度                  |
| 广度优先搜索（BFS）| O(n)       | O(n)       | 队列实现；图/树的遍历                     |

## 总结
### 1. 核心规律
- 双层嵌套循环 → 大概率O(n²)（如冒泡/选择排序）；
- 分治/二分 → O(log n) 或 O(n log n)（如快排/二分查找）；
- 哈希表（Object/Map/Set）查找 → 平均O(1)（JS开发优先用）；
- 未优化递归 → 易出现O(2ⁿ)（需用记忆化/动态规划优化）。

### 2. 实用建议
- 日常排序优先用`Array.sort()`（O(n log n)），避免手写O(n²)排序；
- 数组查找优先用`Map/Set`（O(1)），替代线性遍历（O(n)）；
- 数组增删优先用尾部操作（`push/pop` O(1)），避免头部操作（`shift/unshift` O(n)）。

### 3. 记忆技巧
把“算法类型-复杂度-JS方法”绑定记忆（如：快排=O(n log n)=`Array.sort()`；二分查找=O(log n)=有序数组查找；哈希查找=O(1)=`Map.get()`）。




<br><br><br><br><br>


JS 常见写法的时间复杂度速览
假设输入规模为 n。
单层遍历：O(n)
for (let i = 0; i < arr.length; i++) { /* ... / }
arr.forEach(x => { /* ... / }); // 同上
访问一次数组/链表等线性结构。
双层嵌套遍历：O(n²)
for (let i = 0; i < n; i++) {
for (let j = 0; j < n; j++) { /* ... / }
}
常见于比较两两元素、构造矩阵等。
非对称嵌套：O(n·m)
for (const a of listA) {
for (const b of listB) { /* ... / }
}
规模分别是 n、m。
提前 break 的遍历：最坏 O(n)，最好 O(1)，平均视命中概率。
for (const x of arr) { if (x === target) break; }
分治 / 二分查找：O(log n)
// 前提：arr 已排序
function binarySearch(arr, target) { /* ... / }
排序：内置 Array.prototype.sort 平均 O(n log n)，最坏实现相关。
线性扫描找最大/和：O(n)
const max = arr.reduce((m, x) => Math.max(m, x), -Infinity);
映射/筛选：O(n)
const doubled = arr.map(x => x * 2);
const evens = arr.filter(x => x % 2 === 0);
includes / indexOf（数组）：最坏 O(n)。
arr.includes(target);
Set / Map 查找、插入、删除：平均 O(1)，最坏退化 O(n)。
const set = new Set(arr);
set.has(x); // 平均 O(1)
对象属性访问：平均 O(1)，同样受哈希实现影响。
obj[key];
队列/栈操作：入/出平均 O(1)
栈：push/pop
队列：避免 shift（O(n)），用双端队列写法或手动 head 指针；push/pop 在尾部是 O(1)。
链表按位置访问：O(k) 线性走指针；头插/删 O(1)，中间插/删需先走到位置 O(k)。
矩阵遍历：O(rc)
for (let r = 0; r < rows; r++) {
for (let c = 0; c < cols; c++) { /* ... / }
}
三重循环：O(n³) 典型于三元组枚举。
递归深度与栈空间：递归 O(depth) 额外空间；尾递归在 JS 不保证优化，迭代更安全。
哈希去重 vs 排序去重：
哈希去重：O(n) 时间，O(n) 空间
const unique = [...new Set(arr)];
排序后去重：O(n log n) 时间，O(1) 额外空间（若就地排序）
滑动窗口 / 双指针：O(n)
let l = 0;
for (let r = 0; r < n; r++) {
// 调整 l ...
}
哈希计数统计：O(n)
const freq = new Map();
for (const x of arr) freq.set(x, (freq.get(x) || 0) + 1);
图遍历：
BFS/DFS：O(V + E)
优先队列 Dijkstra（二叉堆）：O((V + E) log V)
空间复杂度常见模式：
原地操作：O(1)（如双指针交换、部分排序算法）
额外数组/哈希：O(n)
递归：栈深 O(depth)
快速判断口诀
单循环 → O(n)；嵌套多少层，大约 n 的多少次方
排序常见 O(n log n)
哈希/集合/映射均摊 O(1)
二分/平衡树/堆相关常见 log n
图遍历看点和边：O(V + E)
