(web.dev)[https://web.dev/articles/lcp?hl=zh_cn]



# 零、前言
本文主要探讨网页前端性能优化的四个关键步骤：量化、诊断、优化和监控页面性能。
- 量化：通过网页核心指标（Core Web Vitals）量化当前页面性能。
- 诊断：利用性能诊断工具和用户数据分析发现性能瓶颈和优化机会。
- 优化：针对问题进行优化，并比较优化前后的性能指标。
- 监控：使用自动化工具进行持续性能监控，防止性能回归和劣化。
基于Google的性能指标，通过系统性的分析对网页性能和体验进行优化，以实现有条不紊、循序渐进的性能检测与优化。

# 一、背景
## 1.用户环境
9pon主要面向海外印尼地区的用户，此部分地区用户的设备性能和网络状况相较于国内会差很多，因此对网页加载速度的感知会更明显。

## 2.必要性
2.1 减少用户流失
Think with Google报告指出，页面加载时长与用户流失率有密切关系，当加载时长从1秒增加到5秒，用户跳出率会增加90%。

- ![](https://p9-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/d06d94193db74560a64a04ce105059f3.png~tplv-a9rns2rl98-image.png?rcl=20260105103513F32E327AAE06A84B83E3&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083804513&x-signature=cbuoVByX5RRApBkUW7V2y4hyCZU%3D)

缓慢的页面加载时长在影响用户体验的同时也非常考验用户的耐心，每增加一秒加载时长意味着消磨着用户的耐心和增加用户的跳出率，即使再有耐心的用户也会因为迟迟加载不出页面而选择离开。

## 2.2 SEO优化
Google官方一直在鼓励网页给用户带来更好的体验，为此将一些衡量网页性能的指标纳入到其搜索引擎排名算法中，以奖励那些交互友好和给用户带来更好体验的页面，为其带来更大的流量潜力。

## 2.3 用户体验
用户体验友好的页面可以提高用户会话数、停留时长，为用户带来愉悦的体验的同时也提高了用户粘性，为提高用户转化率带来更多的可能。
因此，为减少页面加载时长，提高用户体验，降低用户流失率，需要对页面的用户体验和性能进行针对性地优化。



# 二、基本流程
## 0. 一句话概括
量化->诊断->优化->监控
- 用量化指标来衡量当前页面性能
- 通过诊断分析工具或采集统计用户数据来发现当前页面的性能问题或瓶颈
- 基于问题进行针对性的优化，比对优化前后的性能指标差异
- 通过工具实现可持续的性能监控，防止性能回归或劣化

![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/a561e79431964b15a2fc090493f4b8f0.png~tplv-a9rns2rl98-image.png?rcl=2026010510374200AA21782BEE5A3FD0A4&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083804663&x-signature=cly7WOWfoQd%2FqhEZJowXhOL8dyQ%3D)


### 1.量化
#### 1.1 介绍
通过可量化的指标来评估和衡量页面的性能和体验，以获得对当前页面性能的基本了解。之后可以基于页面性能指标进行针对性地优化，通过比对各项指标是否有真实的提升。

#### 1.2 Core Web Vitals
##### 1.2.1 介绍
Google提供了一组web页面性能指标：Core Web Vitals（核心网页指标），Core Web Vitals的指标并不是一成不变的，会随着时间的推移而改变，例如2024年3月INP替代FID成为新的核心指标。
截止至2024.12.01的这组指标分别为
- LCP（最大内容绘制时间）,
- INP（交互到下一帧绘制的时间）,
- CLS（累积布局偏移），
  
分别对应用户体验的三个方面：
- 加载速度，
- 互动性，
- 视觉稳定性。
根据页面加载速度、用户输入的响应延迟、网页布局偏移来衡量网页的性能与体验。

![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/ec9f384383cf446cbc16401363343f5b.png~tplv-a9rns2rl98-image.png?rcl=202601051041411630CC6DB38F1FCE2217&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083804901&x-signature=gFortjFhWfvuZ3fdPerCtCCNhks%3D)

##### 1.2.2 Largest Contentful Paint (LCP)
![](https://p9-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/f0fc51619ef945758743ea21618e0cc1.png~tplv-a9rns2rl98-image.png?rcl=202601051042298FF860288123E6D7AE55&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083804949&x-signature=V5bqWrPh4R2w1mXi8SLzUvF2sEE%3D)

###### 1.2.2.1 作用
视图内最大内容的绘制渲染时间，用于衡量网页主要内容加载速度。

###### 1.2.2.2 重要性
- 反映加载速度
是影响用户对网页加载速度感知的重要因素，可真实反映用于对网页加载速度的直观感受。
也是研发衡量网页加载速度的重要指标，帮助研发识别影响页面性能的关键资源。

- 影响SEO排名
同时，Google将LCP指标纳入到其搜索引擎排名算法中，较低的LCP意味着较低的搜索引擎排名，会影响网页SEO（Search Engine Optimization）。

- 混合开发时，可帮助优化移动设备的内存使用和电流消耗
优化LCP通常会拆分和压缩资源，拆分复杂的长任务，减少不必要的重绘和重排操作等，可降低CPU的功耗和内存使用，以减少移动设备（Android或ios）的电流消耗。

###### 1.2.2.3 统计方式
网页通常分阶段加载，因此网页上最大内容可能会发生变化。开始加载页面时浏览器会将绘制的第一帧识别为最大内容元素。在渲染后续帧时，浏览器会将更大的内容识别成最大内容元素，直到用户开始与页面进行互动才会停止记录。因此从 页面加载起点 到 图片绘制完成 的时间即LCP。

###### 1.2.2.4 示例
下图会标记页面在不同时间段的最大内容是哪个元素，开始时将绘制的第一张识别为最大内容元素。页面开始加载渲染文本块时，最大内容变成了文本块。随着页面加载，最大内容变成了紫色的图片，因此LCP是网页加载到此图片绘制完成的时间。

![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/4ba6ea773def47528cf91c8a6d4946f1.png~tplv-a9rns2rl98-image.png?rcl=2026010510495558465E12835F77A62DE5&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083805395&x-signature=qoSUTU5ib8l7a1YLdgibnk6%2F9jI%3D)

##### 1.2.3 Cumulative Layout Shift (CLS)：
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/72ce1f459fad4385ac3932364748ac55.png~tplv-a9rns2rl98-image.png?rcl=202601051051575B1386E2E3FC05BCC527&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083805518&x-signature=J7sGv4qJAqGaVfCCZPrpFDJoGus%3D)

###### 1.2.3.1 作用
累积布局偏移，该指标用于统计网页加载时的元素意外偏移的累计分数。布局偏移是影响用户体验的重要指标，较高的布局偏移分数会影响用户的体验。

###### 1.2.3.2 重要性
越高的布局偏移意味着页面元素的抖动比较明显，用户非常容易误触页面，导致意外的交互发生，影响用户体验的同时也有可能导致用户的流失。

###### 1.2.3.3示例
举个例子，如下图所示，当某个用户在网页加载时想要点击下单按钮，却因为意外的布局偏移和页面抖动导致误触了其他元素，导致影响用户体验的同时可能也导致了订单的流失。

![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/cd353d516d07477688e9db03cdffcb7c.png~tplv-a9rns2rl98-image.png?rcl=20260105111739D3CE67813D8A4040FD2D&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083807059&x-signature=o5DZmFrp8eRC1Uvg1eSyf6Ka44o%3D)

一个交互友好，对用户友好的页面应当尽可能地避免意外的布局偏移，例如为可能导致布局偏移的元素提前预留空间和位置。如下图所示，为加载时间较长的图片预留空间，可以有效地防止用户误点击，后续的优化CLS思路也是遵循着这个思路。

![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/ed7322c71fa94b699e8aacd2d5cf97f2.png~tplv-a9rns2rl98-image.png?rcl=2026010511180830CA3024514731FCBDF8&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083807088&x-signature=EvSXdmmdbJJfcClWge8Njv3nH1k%3D)

##### 1.2.4 Interaction to Next Paint (INP)：
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/ed898a7508474ae1baaef6cff93f7d64.png~tplv-a9rns2rl98-image.png?rcl=20260105112035A4C9528EB2EF97CAB3B8&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083807236&x-signature=eF%2B2gDifGn9HDkGeZf9d7zYMkqQ%3D)

###### 1.2.4.1 作用
交互到下一帧绘制的时间，就是用户在页面上执行交互操作（例如点击）到随后在屏幕的视觉更新或渲染的延迟时间，反映交互的响应延迟，说白了就是用来评价当前页面的交互丝滑与否。用于衡量页面对用户交互的响应速度。
如下图所示，左图的响应速度明显慢于右图，可通过INP直观反映两个页面之间的响应速度和交互流畅度。

![](https://web.dev/static/articles/inp/video/jL3OLOhcWUQDnR4XjewLBx4e3PC3/WSmcjiQC4lyLxGoES4dd.mp4?hl=zh-cn)

###### 1.2.4.2 重要性
- 响应能力
INP可以直观反映出网页的响应能力，越低的INP意味着越短的响应延迟时间和更快的响应速度，能够为用户带来更流畅、更丝滑的交互体验。

- SEO
Google也同样将INP纳入其搜索引擎排序算法中，越低的INP意味着更多的流量曝光潜力。

- 混合开发的页面流畅度
如果是混合开发，页面的INP指标会直观反映app的交互响应延迟和页面流畅度，会影响app在Android或ios的响应延迟和流畅度测试。

###### 1.2.4.3 示例
页面有个轮播图，点击按钮切换到下一张图片，从点击按钮到下一帧绘制的时间就是交互响应延迟时间，会影响INP指标。

![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/311c7406b18d4757b0939ad49a098ab1.png~tplv-a9rns2rl98-image.png?rcl=20260105112424825B1DAE65D1369C7537&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083807465&x-signature=WKhXH1nZeiZE3pX%2FKVMiMrTXr5g%3D)

##### 1.2.5 小结
Google官方建议将第75个百分位数作为衡量阈值，即第75个百分位的数据可以反映大多数用户的平均指标值。如果三个核心指标的第75个百分位都到达了建议的目标，那么表示当前页面性能良好。后续的性能诊断和优化也是为了达到此目标而努力。

## 2.诊断
举个例子，如果将当前网页比喻成一个体检人员或病人，那么LCP,CLS,INP等指标就是体检人员的体验数据，直观反映的网页的”身体机能与健康情况“。性能诊断工具就像听诊器、X光机、CT扫描仪等工具，扫描和发现网页的"健康问题"。研发人员就像医生，持续观察和诊断页面”健康“问题，及时发现和“治疗”页面的性能问题。

![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/6bc51c387e10424ca10362ff55c497f9.png~tplv-a9rns2rl98-image.png?rcl=20260105112507F2CE8739DBE67464C8A1&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083807508&x-signature=tjJGZ6pDOfSvhE%2FddA2GHL%2FEhSc%3D)





### 2.1 介绍
通过性能诊断工具或者采集统计用户真实数据来发现当前页面的性能存在的问题和可优化的机会。

### 2.2 分类
常见的工具分为两类：模拟和预设不同环境的实验室工具（例如lighthouse）和采集统计真实用户数据进行诊断分析的现场工具或平台（例如CrUX）。

#### 2.2.1 实验室工具
##### 2.2.1.1 介绍
通过模拟不同的网络环境和终端设备条件，结合主流的性能诊断工具，系统性地识别和分析开发环境中潜在的性能瓶颈及用户体验问题。

##### 2.2.1.2 工具
- Chrome 开发者工具
- lighthouse 灯塔
- PageSpeed Insights
- WebPageTest
##### 2.2.1.3 示例
例如，可以通过WebPageTest预设的设备、网速、地区等条件，测试该预设条件的页面性能，诊断出可能的问题和优化机会。
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/0cd53623800e4184b5cd09e44cfe2368.png~tplv-a9rns2rl98-image.png?rcl=20260105113537B48A6EFF260416BE9A6D&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083808137&x-signature=%2BpcW%2FSx%2BQeKZMj9RE0P6b%2BqA11g%3D)

#### 2.2.2 现场工具
##### 2.2.2.1 介绍
基于真实用户性能指标（real user monitoring，简称RUM）的采集与数据分析，深入洞察生产环境中的用户体验痛点，从而发掘具有实际价值的性能优化空间。
##### 2.2.2.2 工具
- Chrome 用户体验报告（CrUX）
- PageSpeed Insights
- Search Console（“Core Web Vitals”报告）
- web-vitals JavaScript 库

##### 2.2.2.3 示例
CrUX作为Google官方公开统计的性能数据集合，进入CrUX信息中心即可查询过去28天内的真实用户在chrome浏览器的性能数据分布情况。

![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/8cde469997144468affc95a1267f46e5.png~tplv-a9rns2rl98-image.png?rcl=202601051143579526E9241B7EF2E1731D&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083808637&x-signature=qU5HI5fP%2BiKBQ3XwKkhmixvWcW4%3D)


#### 2.2.3 常见工具介绍
##### 2.2.3.1 chrome 用户体验报告(CrUX）
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/a0bdf291e9d3459da18d8317f5962aa6.png~tplv-a9rns2rl98-image.png?rcl=20260105114433C5B4388547A5E5CAE4FE&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083808673&x-signature=Sq1gbmQzXIuROUhXgYI5HOMUQig%3D)

是一套公开的实测数据，基于真实的chrome浏览器用户在过去28天内的实际访问数据，统计出core web vitals指标的分布情况（CrUX信息中心链接），可通过参考CrUX数据了解网站的页面性能概览和趋势。
![](https://p9-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/281b099462f84098b058915236d9bbb7.png~tplv-a9rns2rl98-image.png?rcl=20260105114516E0BD96EEFF3ACF4496DC&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083808717&x-signature=AXYwoX66ydLd%2FQW6vDSDq2wudD0%3D)

在CrUX信息中心输入想要查询数据的网址
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/c95a83879abf41c5bbfbe6b8fdd61b8a.png~tplv-a9rns2rl98-image.png?rcl=20260105114516E0BD96EEFF3ACF4496DC&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083808717&x-signature=KK3GJdfdO%2BXxjqjgQ3er6iB0c%2FQ%3D)

即可查询出真实用户通过chrome浏览器访问该网址的core web vitals指标的百分位分布。

##### 2.2.3.2 灯塔lighthouse
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/8c8ce86e45604228ad37a4b631868f69.png~tplv-a9rns2rl98-image.png?rcl=20260105141904DF5ED1A9E686EF0D630A&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083817944&x-signature=Ru6hOumjxSJ9t7hqY0c7dQATjZ4%3D)

作为Google官方推出的性能诊断工具，lighthouse有chrome插件，node服务，可通过模拟设备（移动端或者PC端）、网速延迟（例如3G、4G等）这些预设的条件对页面进行性能诊断，生成性能测试报告，反馈当前页面的性能指标（metrics），诊断（diagnostics）出的性能和体验问题，以及可优化的机会（opportunities）。
例如WebPageTest,PageSpeed Insights等常见的性能诊断工具的底层都集成了lighthouse的性能诊断能力。
虽然没有使用真实的用户现场数据，但是通过预设条件进行诊断可以有助于本地开发时及时发现当前迭代版本带来的性能劣化，以及发现预设环境的性能优化机会。
同时，可以基于lighthouse-CI或者自动化测试工具将lighthouse诊断能力集成到CICD中，实现自动化诊断性能问题和发现性能优化机会。

##### 2.2.3.3 PageSpeed Insights(PSI)
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/6d0a5dd0022048e9940278c2c5c1f669.png~tplv-a9rns2rl98-image.png?rcl=20260105142310D70FF919D23C6827690C&rk3s=8e244e95&rrcfp=dafada99&x-expires=2083818190&x-signature=I13%2FsR2KorS7LJULcnKBuZ3BUFw%3D)

与前两个工具不同的是，PageSpeed Insights集成了lighthouse在预设环境的性能诊断能力和CrUX采集的真实用户数据集合。既能发现网页在预设环境和条件的优化机会，也能帮助发现真实用户在生产环境的页面性能问题（诊断工具链接）。

##### 2.2.3.4 Real User Monitoring（RUM）
采集和埋点上报用户的核心指标数据（例如web-vitals），监控用户的性能指标数据，相较于CrUX更加灵活，数据更加全面，更有利于分析不同地区、网速、设备的用户的实际页面加载时长和用户体验。

#### 2.2.4 小结
通过实验室工具可以预设不同环境的页面性能，模拟弱网有助于发现和排查平时难以发现的性能瓶颈。通过现场工具采集真实的用户数据有助于了解用户的真实用户体验和页面性能分布情况，有利于发现真实用户遇到的性能问题和观察优化后的性能变化。两类工具相辅相成，共同推动页面性能问题的诊断和优化。

## 3.优化
基于性能诊断工具及真实用户监测数据（RUM）所发现的性能瓶颈与体验痛点，制定针对性的优化策略，以提升网页性能表现。
不同项目的性能问题和可优化机会不同，像WebPageTest,lighthouse,PageSpeedIngights等工具会提供诊断建议和优化机会，下文将基于core web vitals指标（LCP,CLS,INP）发现的常见性能问题进行优化。

### 3.1 LCP（加载速度）
#### 3.1.1 思路
![](https://p9-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/bc1aff02b42b4e2688e7b16e49a038d6.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=20260112183727B0823AE3F55EEEFF070A&rrcfp=dafada99&x-expires=2084438247&x-signature=vQWH%2FGIDWOptdVPxjPGiw3tMR7U%3D)

从以上瀑布图可以看出初始HTML文档和LCP资源加载和渲染时长是影响LCP指标的两个主要因素，LCP时间可以细分为以下四个部分：
- **到第一字节时长（Time To First Byte,TTFB）**
从发起请求到第一个字节响应到前端的时长
- **LCP资源加载延迟**
从受到第一个字节响应，到LCP资源开始加载的延迟时间
- **LCP资源加载时间**
LCP资源的请求和加载时间
- **LCP元素渲染时间**
LCP资源加载完成之后，LCP元素渲染所用时间

假设以上四个部分没有重叠，那么LCP就是这四个子部分之和。
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/bbe2c2b9f2054c77a994bde68c24d563.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=20260112183957AA5E302DF076698B41D2&rrcfp=dafada99&x-expires=2084438397&x-signature=yEwEHM6ppsD6VA6gMgNe1PKa2VU%3D)

因此，优化LCP时间本质上就是优化和减少以上四个部分的时间。其中，Google统计的影响LCP的主要子部分是TTFB和LCP资源加载时间，正所谓打蛇打七寸，因此这两部分是优化LCP的主要机会。

#### 3.1.2 实践
##### 3.1.2.1 确保 LCP 资源尽早开始加载
如果LCP资源是JS动态添加到网页中或者CSS背景图，那么需要运行脚本或CSS文件才会开始加载此LCP资源，会导致LCP资源加载的延迟。

- **预加载LCP资源**

```html
<!-- Preload the LCP image with a high fetchpriority so it starts loading with the stylesheet. -->
<link rel="preload" fetchpriority="high" as="image" href="/path/demo.webp" type="image/webp">
```

在 HTML 中使用 <link rel="preload"> 标记预加载资源，那么在浏览器扫描HTML文档的时候就可以发现LCP资源和预加载，从而达到提前发现LCP资源的效果，降低资源加载延迟。

- **提高LCP资源的优先级**
即使浏览器能从HTML找到标记的LCP资源，也可能不会最高优先级加载，因为图片不是阻塞渲染资源。而且，LCP图片可能会因为设置了懒加载属性（loading="lazy"），或者有其他资源设置了更高的优先级，导致浏览器延迟加载LCP资源。
因此，需要通过设置fetchpriority="high"属性来提高优先级，告知浏览器需要优先加载LCP资源。示例如下:

```html
<img fetchpriority="high" src="/path/demo.webp">
```
因为请求资源的带宽是有限的，可通过降低某些资源的优先级来为关键资源提供更多的带宽。例如某些图片在首屏加载是不可见的或者轮播图的不可见图片，可降低其优先级。
```html
<img fetchpriority="low" src="/path/demo.webp">
```

- 小结
最理想情况的降低LCP资源加载延迟的状态如下，第一个资源与LCP资源同时加载。
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/ce2cfd4e5cf242a8bf1a1b8b2b9966e7.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=20260112184032EE1179E72C8DD6F147DD&rrcfp=dafada99&x-expires=2084438433&x-signature=%2BQm%2BclZm%2FbUhZ%2B5rheVRo4bNVhQ%3D)

##### 3.1.2.2 减少元素渲染延迟
以下图为例，即使LCP资源已经加载好了，由于Stylesheet样式表的加载时间明显长于LCP加载时间，导致后续渲染流程都被阻塞

![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/3c5ec14ac7b04311a3845b1ef446e226.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=202601121841030CCA72737DC99AFC1C5B&rrcfp=dafada99&x-expires=2084438463&x-signature=FdlAuerCqNtZa9r6B4MwyMlwqoI%3D)

因此，需要减少样式表的加载时间，常见的优化样式表建议如下：
- **压缩样式表体积**
压缩样式表的体积，例如删除不必要的空格、缩进、换行符、注释等内容。例如webpack、vite等构建工具都会配有主流使用的css压缩工具，例如vite的PostCSS和esbuild。

- **移除无用冗余的样式表内容**
有些样式代码和规则其实并没有实际使用，那么在打包的时候就可以将其移除掉，例如vite可以通过vite-plugin-purgecss插件移除未使用的css。

- **服务端渲染SSR**
  ![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/06814c46994249caa6098798cd986fc2.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=202601121841190F068D557E61128D3F2C&rrcfp=dafada99&x-expires=2084438479&x-signature=vtGzVX6whNQ%2BcACVnavrwNj58Ds%3D)

即服务端渲染，即在服务器上运行客户端逻辑，响应完整的HTML文档请求。
主要优势在于图片资源可在HTML中找到，同时无需等待其他的JavaScript请求就可呈现页面内容。唯一的缺点就是需要额外的服务器处理时间，会导致TTFB的降低。但是由于服务器处理时间在研发人员的可控范围（配置服务器规格等），而用户的网络和设备不在可控范围，因此这种取舍是值得的。

- **路由懒加载**
对于SPA应用，每个路由对应一个页面，如果不做懒加载，会在首页加载时一次性加载所有资源，由于js资源的加载会阻塞首屏渲染，导致首屏加载很慢和影响用户体验。
因此，可以基于es6的import()实现路由懒加载，基于路由动态加载各个模块，动态加载的子模块在构建时会被拆分成单独的文件。在打开首屏或者某个路由时只会加载关键资源，非关键资源的加载被延迟，带宽竞争的减少使得LCP资源可以尽快加载。

如以下示例：
路由懒加载前的js初始体积：
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/59c17b1ee49f4992a7346dd6595d2587.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=202601121847523B08B09B9C72AC60DEE5&rrcfp=dafada99&x-expires=2084438872&x-signature=t6Qevo73uGW4VTXvuTJIzxKHdtw%3D)

全部改成路由懒加载之后：
```js
const Home = () => import("@/views/home/index.vue");
// 其他懒加载的路由页面组件...

const routes = [
    {
       path: "/",
       name: "home",
       component: Home
    },
    // 其他懒加载的路由页面组件...
]
```

可以看到首页js资源拆成了app.js和home.js，体积是之前的23%左右。
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/2188b8585fdc46fe83afe0ae63ef5a88.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=202601121847523B08B09B9C72AC60DEE5&rrcfp=dafada99&x-expires=2084438872&x-signature=NEuoHrIZ%2B00o7xgTAr%2Fv4mv3XJE%3D)

同样的，css资源也会随之拆分，体积也明显小于优化前的体积。

- **组件懒加载**
与路由懒加载类似，一些非关键组件，在首屏渲染的时候不会加载和渲染，可以通过import()动态加载组件，实现组件懒加载。
如以下代码所示，home页面通过懒加载popup组件，那么构建打包时会把popup单独拆成一个chunk，进一步减少首页js文件的体积大小。
```js
const popup = () => import('@/components/popup');
```

###### 3.1.2.3 尽可能缩短 LCP 资源的加载时间
在不牺牲质量的情况下，尽可能减少资源通过网络传输到用户设备所化的时间，主要分为以下四种方法：
##### 3.1.2.3.1 减少资源的传输距离
- **使用CDN（内容分发网络）**
通过CDN存储图片资源，那么请求CDN资源时会尽可能地寻找地理位置最近的服务器节点，可以有效减少资源的传输举例。并且CDN通常可以满足资源的压缩和裁剪需求。


###### 3.1.2.3.2 压缩资源大小
- **使用现代图片格式（webp或avif）**
相同清晰度的图片，webp与jpg和png相比，通常文件大小会减少25%-35%，有助于在保证图片清晰度的情况下压缩图片资源体积以提高性能。
YouTube和Facebook等网站的数据佐证了webp图片所带来的网页性能提升（数据来源：web.dev-使用WebP图片）：
- YouTube 发现，改用 WebP 缩略图后，网页加载速度提高了 10%。
- 当 Facebook 改用 WebP 后，JPEG 文件的文件大小缩减了 25-35%，PNG 文件的文件大小缩减了 80%。
而avif与webp相比，有着更强的图片压缩能力（参考资料：web.dev-使用AVIF压缩网站上的图片），但由于avif的兼容性不如webp，因此使用avif时要考虑到兼容性问题。

- **使用最佳图片大小（二倍图或三倍图）**
举个例子，某个图片的实际渲染宽高都是50px，但是却请求了实际宽高是5000px的图片，那么就会造成资源的浪费，有”杀鸡焉用牛刀“的既视感。一般使用两倍图或者三倍图就可以渲染出非常清晰的图片了，那么刚才举例的场景只需要请求实际宽高是50*3 = 150px的三倍图就足矣。

- **示例**
如果图片资源使用的是OPPO的CDN域名，那么可以通过配置url参数来配置图片的宽高和图片格式，代码示例如下：

```js
/**
 * 只支持具备实时压缩图片功能的CDN使用该功能
 *
 * width:   压缩后的图片宽度, 0代表自适应
 * quality: 压缩后的图片质量, 最大100
 * */
export const compressImg = (url: string | undefined, opts: { width?: number; height?: number; quality?: number }): string => {
  if (!url) {
    return '';
  }
  // 是否为oppo的cdn域名图片
  const isOppoImg = url.includes('9ponmobile.com');
  if (!isOppoImg) return url;
  // 如果是，那么通过拼接参数来配置正确尺寸的图片
  const { width = 0, height = 0 } = opts;
  let size = '';
  width && (size += `,w_${width}`);
  height && (size += `,h_${height}`);
  return `${url}&x-amz-process=image/resize,m_fill${size}/format,webp`;
};
```

###### 3.1.2.3.3 减少LCP资源的带宽竞争
上文有提到，通过配置较高的fetchpriority可以告知浏览器尽早地加载此资源

###### 3.1.2.3.4 完全消除资源加载时间
听起来有点玄幻，为什么加载资源的时间可以被消除掉？其实就是通过合理的缓存策略将图片资源缓存起来。


如果前端项目是部署到服务器，那么可以通过配置NGINX使得响应header带上缓存相关的响应头，例如Cache-Control：
```js
server {
    ...
    location / {
        add_header    Cache-Control max-age=2592000;
    }
    
    ...
}
```

如果项目是静态部署，那么可以通过配置云平台接入服务的对应域名的API网关，给访问静态资源的路径path配置返回响应头
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/99910a7aabb74085b210237e7d1e08b7.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=202601121847523B08B09B9C72AC60DEE5&rrcfp=dafada99&x-expires=2084438872&x-signature=J83YxmLSNbYY5p8UiOEJRv6W9RE%3D)

补充一点，因为缓存策略会影响资源的即时性，那么可以通过给文件名添加版本号或哈希值来确保浏览器请求资源的及时更新。

##### 3.1.2.4 缩短TTFB
即尽早提供HTML内容，常见导致TTFB慢的原因是重定向，因此要尽可能减少用户的重定向次数。

### 3.2 CLS（视觉稳定性）
> 参考 [web.dev/cls](https://web.dev/articles/cls?hl=zh_cn)
> 这一个章节由于很多图片都是动图，所以无法上传，具体参考 [web.dev/cls](https://web.dev/articles/cls?hl=zh_cn)

lighthouse,PageSpeed Insights等工具会检测出页面中导致布局偏移的元素，可根据诊断工具的建议和提示进行优化，以下是常见的导致CLS偏高的原因和对应解决方案。

##### 3.2.1 没有指定尺寸的图片
比较常见的场景就是渲染图片前没有预留位置和空间给图片导致的布局偏移。
以下图为例，文字块比图片先渲染，但是没有预留位置给图片，导致图片渲染前没有占位，图片渲染后会把其之后的文字内容给挤下去，导致布局偏移。

- ![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/6f2c409fde28469a8baeacf080519699.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=20260113102924E253D2779E2417C5755A&rrcfp=dafada99&x-expires=2084495364&x-signature=%2F6lEMXLaEsYgW5IBkO7gvL2Pue4%3D)
- ![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/b607cc8604274d21ad215e5a1367fe09.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=20260113102924E253D2779E2417C5755A&rrcfp=dafada99&x-expires=2084495364&x-signature=rwOE2YUZhK8lW6axiMW4GtWChPM%3D)

没有预留位置给图片的本质原因是图片没有设置明确的宽度和高度，导致浏览器在图片实际渲染前无法明确图片的实际渲染宽高，导致无法预留准确的空间给图片。这里需要注意的是，图片需要 **设置明确的宽度和高度**（像素、百分比、rem等都可以），浏览才能在渲染前明确要预留给图片的空间。

比较常见的导致布局偏移例子就是为了让图片适配多端屏幕，需要设置宽度100%，高度设置适应内容高度（auto），那渲染前浏览器只知道图片的宽度是100%，但是需要渲染之后才明确高度是多少，导致布局偏移
```css
img {
  width: 100%;
  height: auto; // 浏览器无法在渲染前明确图片的高度，导致无法预留准确的空间
}
```

最简单粗暴的解决方案就是通过设置图片的width和height属性明确其宽高。如果要实现图片在多端的自适应渲染大小，那么可以通过设置明确的width或height，通过aspect-ratio设置宽高比来为图片预留空间。

以下面的代码举例，假设页面在屏幕宽度500px的设备渲染，那么浏览器在图片渲染前就可以知道图片渲染宽度是屏幕宽度的100%也就是500px，高度是 500px * 5 / 4 = 400px，那么就可以在图片渲染前为其预留宽度500px、高度400px的位置，避免图片导致的布局偏移。

```css
img {
  width: 100%;
  aspect-ratio: 5 / 4; // 浏览器无法在渲染前明确图片的高度，导致无法预留准确的空间
}
```

以下是指定图片尺寸的页面加载效果，可以看到浏览器已经在图片渲染前为图片预留了准确的空间和位置，图片在渲染后并没有导致布局偏移和抖动。

- ![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/33d715d2384545b493c66f5ef9e502e9.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=20260113102957DEFB44F858A77B613B32&rrcfp=dafada99&x-expires=2084495397&x-signature=OPT3W9yjm%2BNHrk35UIr1p2HDktY%3D)
- ![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/b607cc8604274d21ad215e5a1367fe09.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=20260113102924E253D2779E2417C5755A&rrcfp=dafada99&x-expires=2084495364&x-signature=rwOE2YUZhK8lW6axiMW4GtWChPM%3D)

最后再把设置了图片指定尺寸和没设置指定尺寸的页面加载的直观对比，可以发现指定图片尺寸之后的页面视觉更稳定，这也是为什么Google将CLS纳入核心网页性能指标的原因之一，归根到底是因为视觉稳定性。


#### 3.2.2 动态注入内容
##### 3.2.2.1 提前预留位置
动态注入的内容（例如广告、iframe等）也会导致其后的内容向下偏移，如果提前知道内容的位置和尺寸，可以通过设置min-height或者aspect-ratio等CSS属性为其减少偏移。
- [](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/4f1e31d88d9a431885419c50986d8a14.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=202601131035392401B728F87574383068&rrcfp=dafada99&x-expires=2084495739&x-signature=8C2ISXj3FlUrxYDRYjMKx2TYBHM%3D)

如果无法明确内容尺寸，可能无法完全消除布局偏移，需要根据历史数据来评估和预留最佳的可能预留空间。
如果预留的位置没有内容（例如查接口没有返回内容），Google官方的建议是”请尽量通过显示占位符来避免收起预留的空间。移除为元素预留的空间可能会导致与插入内容一样多的 CLS“。

##### 3.2.2.2 将延迟加载的内容尽可能放在视图下方
与在视图下方注入内容相比，在视图上方注入内容会导致更多的布局偏移。

#### 3.2.3 动画
实现动画时，更改部分css属性会导致重新布局，例如top和left属性，即使这些元素在自己的层也会导致页面整体的CLS，因此需要避免使用影响CLS的属性。尽量使用transform等CSS属性来实现平移、缩放、旋转或倾斜等动画来减少对CLS的影响。

#### 3.2.4 网页字体
网页字体的加载也会导致布局偏移，下图是网页字体导致布局偏移的示例：
- ![](https://p9-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/98de7ecdbbde426fa21d9432912cf8b7.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=202601131035392401B728F87574383068&rrcfp=dafada99&x-expires=2084495739&x-signature=e1W0HdWObvdO8rx44TDV3DmrRu8%3D)
- [](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/eff4ef9bbe0c439aa473d33f36178800.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=202601131035392401B728F87574383068&rrcfp=dafada99&x-expires=2084495739&x-signature=gfIhINsygZ3QmsmkpMdv5oVOFyM%3D)

如果页面设置了网页字体，那么在下载字体之前一般通过以下两种方式下载和渲染页面字体：
- **FOUT（Flash of Unstyled Text）**
  - 浏览器会先使用后备字体（通常是系统默认字体）来显示文本。当网页字体下载完成后，浏览器会用下载的网页字体替换掉后备字体。这会导致用户在字体替换的瞬间看到文本样式的变化。

- **FOIT（Flash of Invisible Text）**
  - 浏览器在网页字体下载完成之前，不会显示任何文本。文本是“不可见”的，直到网页字体下载完成并应用到文本上。这会导致用户在字体下载期间看不到任何文本。

但是以上两种方法都会导致布局偏移，即使是FOIT，浏览器也会在文本不可见的时候使用回退字体进行排版，当网页字体加载的时候，网页字体会导致文本块及其周围的内容发生偏移。
常见的解决方案有通过<link rel=preload>尽早加载字体，如果预加载的字体满足首次绘制条件就会避免布局偏移。

3.2.5 往返缓存
往返缓存（back/forward cache，e简称bfcache）是浏览器的特性功能，是向前或向后导航的时候可命中的缓存。
浏览器开启bfcache后，浏览过的页面生成快照存到内存里，返回或者前进的时候浏览器直接加载缓存的快照页面，减少了不必要的请求。可以显著改善浏览体验，尤其是网络或设备网速较慢的用户。


|是否开启bfcache|情况|
|---|---|
|未启用|发起新的页面请求，部分资源需要重新下载、解析、执行。|
|启用|没有新的请求，直接加载缓存的页面快照，即时加载页面。不仅加快导航速度，同时减少流量消耗和无需再次下载资源。|

同时，Chrome 使用情况数据显示，1/10 的桌面版网站和 1/5 的移动用户都是返回或前进导航。启用 bfcache 后，可以显著地提升页面性能和用户体验。
下图是开启和关闭bfcache的直观对比（开启了2.5倍速），可以看到前向前或向后导航时，开启bfcache的页面是使用的页面快照，加载时间更快。

![bfcache 开启前后 效果对比, bfcache on Chrome for Android](https://www.youtube.com/watch?v=cuPsdRckkF0)

一般浏览器默认会开启bfcache，如果发现浏览器不支持当前页面的bfcache，可通过lighthouse等诊断工具分析原因，如下图所示，lighthouse提供了可能导致关闭bfcache的原因：
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/2da729219ba84af9bc9ba0a48631adb9.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=2026011310365082A4512ABE69ED0CAD4D&rrcfp=dafada99&x-expires=2084495810&x-signature=7NJs9zmQyTZaNmYJrkVJaPWkokk%3D)

也可以通过chrome开发者工具排查，如下图所示，依次打开chrome浏览器-开发者工具-Application-Background services-Back/forward cache-点击Test back/forward cache。可以发现是因为页面有监听unload事件导致阻止了bfcache。
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/d1b5f6f686a84585a4634d53e8c9ff58.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=2026011310365082A4512ABE69ED0CAD4D&rrcfp=dafada99&x-expires=2084495810&x-signature=GTcJpiJa33sdS8wfY6YI5OTDbbA%3D)

一般阻止bfcache的原因是页面监听了unload事件，在web.dev关于bfcache的性能优化的介绍中（链接），可以看到主流浏览器（chrome、firefox等）假设页面在unload事件后就不会继续存在，因此关闭了bfcache。如果发现页面有监听unload事件，可以使用visibilitychange或者pagehide事件替代unload事件的监听。

如果当前页面支持bfcache，那么开发者工具会像下图所示，提示支持bfcache。
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/705534c3333c4e0190eb09f4bda21b08.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=2026011310365082A4512ABE69ED0CAD4D&rrcfp=dafada99&x-expires=2084495810&x-signature=ki4uynTxRDmY7MVB1ev5VzCX6M0%3D)






### 3.3 INP（互动性）
#### 3.3.1 思路

交互互动主要分为三个阶段：
- **输入延迟时间**：从用户开始与页面开始交互，到交互时间的回调开始执行的时间。
- **处理时长**：事件回调从开始运行到执行完成所使用的事件。
- **呈现延迟时间**：从回调执行完成，到页面开始呈现下一帧视觉结果的时间。
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/d3bff37bfd6f4a829fdb380c55996bc1.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=2026011310512286817F185CFC6F1C490A&rrcfp=dafada99&x-expires=2084496682&x-signature=vmteM5%2BVwzSXiQTvtdpi8b%2BsZe8%3D)


那么基本的优化思路就是尽可能减少每个阶段的耗时，后续的优化INP也是遵循这个基本思路。

#### 3.3.2 实践
##### 3.3.2.1 减少输入延迟时间
- **减少周期性定时器setInterval**
常用的定时器setTimeout和setInterval的回调执行都有可能会占用主线程（main thread），导致输入延迟。

如下图所示，定时器执行（timer fired）导致了输入相关的回调函数的延迟执行
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/95c4dfaf40d84c5eaee5a8bfbdfcfc0d.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=2026011310512286817F185CFC6F1C490A&rrcfp=dafada99&x-expires=2084496682&x-signature=WXMWs5yNE44c3saFO%2BoO%2BAQAEXk%3D)


setTimeout本身没有太大问题，甚至可以通过setTimeout延迟非关键任务的执行，避免长时间执行任务，让出主线程。

与setTimeout只执行一次的定时器相比，setInterval周期性地每n毫秒执行一次回调，很有可能会影响到主线程的执行和交互。

因此，如果项目代码存在定时器，需要评估这些定时器是否必要的，以及是否可以在合适的时机调用clearInterval()移除定时器。

- **优化事件回调**
  - **拆分长任务**
由于主线程最多只能同时处理一个任务，长任务在运行期间就会阻塞页面交互。
如下图所示，可以将一个长任务拆成多个较小的任务，那么事件回调可以更早地执行。
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/e00490078beb443fa1370add99f9b832.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=2026011310512286817F185CFC6F1C490A&rrcfp=dafada99&x-expires=2084496682&x-signature=kNavu9cY68r9r1d%2F2Z8Tq1G1YQQ%3D)

举个例子，下面的saveFn()函数会一次执行validateForm()校验表单，saveToDatabase()存储数据，updateUI()更新界面
```js
function saveFn () {
  validateForm();
  saveToDatabase();
  updateUI();
}
```
但是有个潜在问题就是浏览器会将这个函数里面的三个函数当作一个任务运行，所以validateForm()和saveToDatabase()会阻塞后续的updateUI()执行和页面更新。

如果有些场景不强依赖数据保存之后再更新界面，可以通过定时器setTimeout()延迟saveToDatabase()的执行，从而拆分当前的任务成两个较小的任务，使得updateUI()可以更早执行

```js
function saveFn () {
  // 优先执行关键任务
  validateForm();
  updateUI();
  
  // 通过setTimeout拆分长任务，延迟执行非关键任务
  setTimeout(() => {
    saveToDatabase();
  }, 0);
}
```

- **web worker优化长任务**
  - 为防止阻塞主线程的执行，可以通过在主线程基于web worker新开一个worker线程，基于postmessage和onmessgae进行线程之间的通信，为JavaScript创造多线程环境将一些耗时较长的阻塞任务交给worker线程处理，worker线程处理完之后再把结果返回给主线程。
  - 举个例子，以下代码如果在主线程执行，会阻塞页面渲染，导致页面处于卡死状态：

```js
let sum = 0;
for (let i = 0; i < 200000; i++) {
    for (let i = 0; i < 10000; i++) {
      sum += Math.random()
    }
}
```

那么可以通过web worker处理耗时长的任务，那么可以避免耗时长的任务阻塞页面渲染
```js
// worker.js
onmessage = function (e) {
  // onmessage获取传入的初始值
  let sum = e.data;
  for (let i = 0; i < 200000; i++) {
    for (let i = 0; i < 10000; i++) {
      sum += Math.random()
    }
  }
  // 将计算的结果传递出去
  postMessage(sum);
}
```
要注意的是，线程之间的通信也会有耗时，建议平均耗时超过50ms的任务才使用web worker，否则会带来不必要的性能损耗。



- ###### **3.减少呈现延迟事件**
  - **减少DOM数量**
一般情况下，页面渲染的时间会随着DOM数量的增加而增加，应当尽可能避免像以下类似嵌套过深的DOM节点：
```html
<div>
  <div>
    <div>
      <div>
        <!-- Contents -->
      </div>
    </div>
  </div>
</div>
```
可以通过扁平化DOM来简化DOM解构，目前主流的前端框架（React、Vue3.x等）都支持framgment避免嵌套组件。

- **懒加载**
视图以外的内容和图片可以通过懒加载的方式延迟渲染，可以有效减短呈现延迟时间。

像常见的ui组件库都支持配置懒加载属性，例如ant design mobile的Image组件支持配置lazy属性实现懒加载。

原生js的方法可以通过IntersectionObserver()或者getBoundingClientRect()判断是否在视图以外，如果在视图以外，可以先配置懒加载和延迟加载。




## 4.监控
### 4.1 背景
Google官方统计的数据表明大多数页面在性能优化的6个月后会逐渐衰退到原本的性能。为防止此类性能劣化现象，需要持续观察线上用户的性能和体验数据。同时建议将性能诊断能力集成到流水线，以实现自动化的持续监控有助于及时发现问题，防止性能退化。

### 4.2 监控方案
#### 4.2.1.统计真实用户（RUM）数据
通过web-vitals库上报核心性能指标，日常持续观察性能指标的变化的趋势

#### 4.2.2 lighthouse-ci

![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/f23a3106e2b54127b08e84e8d6641472.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=2026011310512286817F185CFC6F1C490A&rrcfp=dafada99&x-expires=2084496683&x-signature=3DIHES2%2BvPSmqwHz4d94zVRa2h4%3D)

Lighthouse CI 是一个专门用于持续集成的工具，基于 Lighthouse 构建。它的主要目的是在持续集成过程中自动化地运行 Lighthouse 审计，并将结果存储、比较，以便跟踪性能变化。Lighthouse CI 允许开发者在每次代码提交时自动运行这些测试，以确保网站的质量和性能。具体使用和介绍可以参考使用 Lighthouse CI 监控性能

#### 4.2.3 lighthouse node module
##### 4.2.3.1 介绍
lighthouse提供了开源、免费的node模块工具，集成到node服务，配合自动化工具可以自动化地诊断和发现网页性能瓶颈和优化机会。

##### 4.2.3.2 落地
既然lighthouse可以集成到node模块，那么可以通过自动化工具（例如puppeteer、playwright等）在服务器打开无头浏览器，然后通过lighthouse进行自动化诊断性能和评分，然后可以通过TypeORM将评分结果存储到数据库，通过比对数据查看历史评分的走向和趋势。

##### 4.2.3.3 实践
- **设计node接口入参**
如以下interface所示，device表示模拟设备是移动端还是桌面端，throtting模拟网速限制和延迟，pageName表示当前页面的名称（用于记录历史评分），pageUrl是评分url，env表示环境（开发/测试/预发布/生产环境，用于当前页面在记录不同环境的历史评分）

```ts
interface RequestParams {
  /** 设备类型 */
  device: 'mobile' | 'desktop';
  /** 网络限制类型 */
  throttling: 'mobileRegular3G' | 'mobileSlow4G' | 'desktopDense4G';
  /** 页面名称 */
  pageName: string;
  /** 页面URL */
  pageUrl: string;
  /** 环境变量 */
  env: 'dev' | 'test' | 'pre' | 'prod';
}
```

- **自动化工具**
通过puppeteer或者playwright等常见的自动化工具打开无头浏览器，注意需要在部署服务器的镜像配置所需浏览器内容，如下代码demo所示，通过playwright打开chrome无头浏览器：
```js
import { chromium } from 'playwright';
function lanuchBrowser() {
    const browserServer = await chromium.launchServer({
        headless: true, // 设置为 true 则为无头模式
        args: [] // 配置浏览器的参数
    });
    // ......
}
```

- **诊断页面性能**
启动无头浏览器之后，根据当前启动浏览器的端口port，通过参数传给lighthouse，告诉它此端口有打开浏览器。
同时，将入参的配置（设备、网速、url等）传给lighthouse，启动页面性能诊断评分，等待评分结果。

```js
import * as lighthouse from 'lighthouse/core/index.cjs';
async function getLighthouseScore(param) {
    const { pageUrl: url, throttlingOptions, device, chromePort } = param;
    const options = {
        port: chromePort, // 启动浏览器的端口
        output: 'html',
        logLevel: 'info',
        onlyCategories: ['performance'],
        // 评审指标
        onlyAudits: [
            'first-contentful-paint',
            'largest-contentful-paint',
            'total-blocking-time',
            'cumulative-layout-shift',
            'speed-index',
        ],
        // 模拟网速
        throttling: throttlingOptions,
        // 模拟设备
        emulatedFormFactor: device,
        // 禁用网络请求
        disableNetworkThrottling: true,
        // 禁用 CPU 限制
        disableCpuThrottling: true,
    };
    console.log('options:', options);
    const runnerResult = await lighthouse(url, options);
    await browserServer.close(); // 关闭浏览器
    return {
        score: runnerResult.lhr.categories.performance.score,
        reportFile: runnerResult.report,
    }; // 返回评分结果
}
```

- **存储网页评分**
将`${device}-${throttling}-${pageName}-${env}`作为pageId，通过TypeORM存储评分记录，后续可通过查询数据库比对历史评分记录的走向和趋势

- **历史评分比对**
每次获取到评分结果后，可以与上次评分结果或者前五次评分结果的中位数（Google官方推荐）进行比对。如果最新的评分明显低于上次评分，那么可以返回code:-1表示性能劣化。如果最新评分高于上次评分，可以返回code:0表示性能评分测试通过。

- **服务端自动化**
依次打开【研发云-项目协同-测试管理-服务端自动化】，如下图所示，可以配置接口自动化的用例，配置想要自动化评分的网页信息（网速、设备、url等）

![](https://p9-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/5fc70e95445345cd83a05e83c0981f76.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=2026011310512286817F185CFC6F1C490A&rrcfp=dafada99&x-expires=2084496683&x-signature=r8ng5ywSxwmMjUOQBF4btAwT2ic%3D)

如下图所示，配置结果校验，如果结果符合预期表示自动化测试通过，否则不通过（这里的结果校验和断言根据自己实现的接口返回结果配置）
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/88ad3b7816f74cec98f374d3414c474c.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=20260113110444C5FB351F1922E2310BE8&rrcfp=dafada99&x-expires=2084497484&x-signature=zWcyHlxnljovRluhYMFcOQ5zAp0%3D)
通过配置自动化计划，可以集成刚才所配置的自动化用例
![](https://p9-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/f54561e0fd0c4e21b3219d860068a270.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=20260113110444C5FB351F1922E2310BE8&rrcfp=dafada99&x-expires=2084497484&x-signature=mtZXYAalDdy9Tq0a%2FNFXGHuXubU%3D)

同时，可以通过配置定时任务，每天在固定实践执行自动化计划，如果性能诊断不通过，会通过tt机器人和邮件告警到对应负责人。
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/834f690587964867853ba330671243d7.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=20260113110444C5FB351F1922E2310BE8&rrcfp=dafada99&x-expires=2084497484&x-signature=e4ZNThDs8rrgXj0m0TlIHlrlLuU%3D)

- **持续集成自动化**
配置好自动化测试计划之后，可以将此计划集成到流水线，在页面部署后自动触发，实现自动化性能诊断和流水线卡点。如果卡点不通过，可以配置tt机器人通知流水线的负责人，以实现持续集成的自动化性能诊断与评分。
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/6354958e60934237a1deb175baf0042e.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=20260113110444C5FB351F1922E2310BE8&rrcfp=dafada99&x-expires=2084497484&x-signature=CzwXbAoAz13SHXW3%2Fq9FxcdMEv0%3D)



## 三、总结
不同的页面存在不同的性能瓶颈和优化机会，就像不同的人有不同的身体健康状况，需要结合实验室工具发现开发环境的性能问题和真实用户数据（RUM）分析线上用户的性能问题，”对症下药“。本文主要罗列了常见的性能指标、诊断工具、分析优化思路和监控性能流程，具体问题需要具体分析，希望本文能够给读者带来一些不一样的性能优化思路和参考，感谢阅读。
![](https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/b69858f22029410cbe59497fd858404a.png~tplv-a9rns2rl98-image.png?lk3s=8e244e95&rcl=20260113110444C5FB351F1922E2310BE8&rrcfp=dafada99&x-expires=2084497484&x-signature=UJ3zTxYqWsPEX6GcP4Yphav8fxk%3D)

