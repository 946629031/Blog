# 高效学习三步曲
    - 1.找准知识体系
    - 2.刻意练习
    - 3.及时反馈

- 知识体系：结构化的知识范围
- 涵盖所有知识点；结构化、有组织、易扩展

## 前端知识体系怎么梳理？
- ### **W3C 标准**
    - Html、Css、DOM操作、BOM操作、Ajax、事件绑定
- ### **ECMA 262 标准**
    - 规定 JS 语法标准
        - 变量定义、if else、function定义、原型方式、闭包方式、Promise
- ### 开发环境
    - 代码版本管理、调试、打包上线
- ### 运行环境
    - 加载、性能优化、安全


----

视频看到 1-6



出自： 快速搞定前端初级 JavaScript 面试 1-5 知识体系

----

# 异步编程
- 异步编程前言，为什么会出现异步编程？：[《阮一峰异步编程》](http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html)
    - "异步模式"编程的4种实现方法
        - 一、回调函数
        - 二、事件监听
        - 三、发布/订阅
        - 四、Promises对象
    - [JS 异步解决方案的发展历程以及优缺点](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/11)


----

- [JavaScript基础面试题受益匪浅（转）](https://zhuanlan.zhihu.com/p/79547341)
- [JS基础知识（覆盖JS基础面试题）](https://juejin.im/post/6844903625618096141)

----

# 快速搞定前端初级 JavaScript 面试 
- 慕课网 ( 双越 老师 )
- 主要知识点
    - ES6 Class
    - Promise
    - 模块化
    - 手写代码题
    - webpack (最新版)
    - babel (最新版)
- 做什么？-- 讲解前端基础面试题
- 哪些部分？-- 基础知识，JS Web Api ，开发环境，运行环境
- 技术？-- 原型，作用域，异步，Ajax，事件，Webpack 等

- 基础知识
    - 原型，原型链
    - 作用域，闭包
    - 异步，单线程
- API
    - DOM，BOM
    - Ajax，跨域
    - 事件，存储
- 开发环境
    - 版本管理
    - 调试，抓包
    - 打包构建
- 运行环境
    - 页面渲染
    - 性能优化
    - Web安全

- ## 1-3 几个面试题
    ```
    1.typeof 能判断哪些类型？

    2.何时使用 === ，何时使用 ==

    3.window.onload 和 DOMContentLoaded 的区别？

    4.JS 创建10个 <a> 标签，点击的时候弹出对应的序号

    5.手写节流 throttle、防抖 debounce

    6.Promise 解决了什么问题？
    ```
    - 问题：
        - 拿到一个面试题，你第一时间 看到的是什么？
        - 如何看待网上搜出来的 永远做不完的题海？
        - 如何对待接下来遇到的面试题？
    - 答：
        - 考点
        - 不变应万变 （题可变，考点不变）
        - 题目到知识点，再到题目

    ```
    1.typeof 能判断哪些类型？
        - 考点：js变量类型
            - 基本类型 和 引用类型的区别
            - 深拷贝，浅拷贝
            - 怎么判断 一个东西 是不是对象

    2.何时使用 === ，何时使用 ==
        - 考点：强制类型转换

    3.window.onload 和 DOMContentLoaded 的区别？
        - 考点：页面加载过程
            - 为啥 css 要放在 head 里，为啥 js 要放在 最底下

    4.JS 创建10个 <a> 标签，点击的时候弹出对应的序号
        - 考点：作用域
            - this 指向
            - 闭包

    5.手写节流 throttle、防抖 debounce
        - 考点：性能、体验优化

    6.Promise 解决了什么问题？
        - 考点：JS异步
            - 异步 和 同步 有什么区别
            - 为什么有异步？
            - 异步的应用场景是什么？它在什么地方用？
            - 定时器 该如何使用？
    ```
    - 答：
        - 1.typeof 能判断哪些类型？
            - string number booleam undefined null symbol
            - object ( Array[] , Object{} )
            - function

- ## 4-1 作用域和自由变量
    - 先看题
        ```
        this 的不同应用场景，如何取值？

        手写 bind 函数

        实际开发中闭包的应用场景，举例说明

        创建 10 个 a 标签，点击的时候 弹出对应的序号
        ```
        - 题目解析
            - bind 函数 是改变 this 指向 的方法之一
            - 考察点：1.看你会不会用bind 函数，2.看你手写的逻辑是否清晰
    - 手写 bind 函数
        ```js
        Function.prototype.bind1 = function () {
            // 将参数解析为数组
            const args = Array.prototype.slice.call(arguments)
            // 获取 this ( 取出数组第一项，数组剩余的就是传递的参数 )
            const t = args.shift()
            const self = this // 当前函数
            // 返回一个函数
            return function () {
                // 执行原函数，并返回结果
                return self.apply(t, args)
            }
        }
        ```
        - `arguments` 可以获取 所有传入的参数。但是他是一个 列表，不是数组，所以这里把他转为数组
            - `const args = Array.prototype.slice.call(arguments)` 通过这种方式 就可以把 列表变为 数组
    - 创建 10 个 a 标签，点击的时候 弹出对应的序号
        ```js
        let i, a
        for (i = 0; i < 10; i++) {
            a = document.createElement('a')
            a.innerHTML = i+'<br>'
            a.addEventListener('click', function(e){
                e.preventDefault()
                alert(i)
            })
            document.body.appendChild(a)
        }
        ```
        - > 弹出来的 都是 10 ？？？
        - 问题分析：
            - 上面 i 和 a 都是全局变量
            - `for 循环` 本质上是创建了 多个 `{}` 块级代码
            - 如果 变量的作用域在 `{}` 块级代码内，那就能够达到预期的效果
        - 这个问题有两个解法
            ```js
            // 利用块级作用域，将 i 的作用域 放在 `{}` 块级代码内
            
            let a
            for ( let i=0; i<10; i++) {
                a = document.createElement('a')
                a.innerHTML = i + '<br>'
                a.addEventListener('click', function(e){
                    e.preventDefault()
                    alert(i)
                })
                document.body.appendChild(a)
            }
            ```
            ```js
            // 将变量放在 函数作用域内

            for(var i=0;i<10;i++){

                (function(i){
                    var a=document.createElement('a');

                    a.innerHTML=i+'<br>';

                    document.body.appendChild(a);

                    a.addEventListener('click',function(e){
                        e.preventDefault();  //取消默认事件，指a标签
                        alert(i);
                    });

                })(i);

            }
            ```
    - 前言：为什么要学？作用域和闭包
        - 面试过程中 如果 `作用域和闭包` 过不了的话，这个人我是不会要的
        - 如果 `作用域和闭包` 搞不清楚，在项目中 模块间相互调用，会产生 比较复杂的关系
        - 你如果这些关系屡不清，关系的作用域的问题，我是肯定不能要你的。要你来 写的代码 不知不觉 就会写出很多BUG 来
    - ### 作用域
        - 作用域 是什么？
            > **作用域就是一个变量的合法使用范围**

        ![](./img/0.interview-question/1.jpg)
        - #### 作用域 有三种
            ```
            全局作用域

            函数作用域

            块级作用域 (ES6新增)
            ```
            - 块级作用域
                ```js
                // ES6 块级作用域
                if (true) {
                    let x = 100
                }
                console.log(x) // 会报错
                ```
                `if , for , while ...` 后面的 `{}` 内都属于块级作用域
    - ### 自由变量
        - 自由变量 是什么？
            > 一个变量在当前作用域没有被定义，但被使用了
        - 向上级作用域，一层一层一次寻找，直到找到为止
        - 如果到全局作用域 都没找到，就会报错 xx is not defined
- ## 4-2 闭包
    - 1.下面代码的输出是什么？
        ```js
        function create () {
            const a = 100
            return function () {
                console.log(a)
            }
        }

        const fn = create()
        const a = 200
        fn()
        ```
        ```js
        function print (fn) {
            const a = 200
            fn()
        }

        const a = 100
        function fn () {
            console.log(a);
        }

        print(fn)
        ```
        - 答案：都是 100

    - **闭包：自由变量的查找，是在函数定义的地方查找，而不是在函数执行的地方！！！**
    - ### 什么是闭包？
        - **闭包是作用域应用的特殊情况**，有两种表现：
            - > 函数作为返回值
            - > 函数作为参数被传递
    - [闭包 定义2](https://www.jianshu.com/p/80b273701ab2)：

        用高程里面的话说就是

        **有权访问另一个函数作用域中的变量的函数**

        其实是一个特别简单的东西，却被搞的好像很复杂。我们平时写得代码里经常写闭包。比如

        **我想把1存起来，下次调用的时候再打印出来**，由于作用域链的关系，fn()之后匿名函数还引用着a,所以a不会被清理掉，下次调用的时候就会打印出来了。
        ```js
        function fn(a){
            return  function(){
                console.log(a)
            }
        }
        fn(1)()//1
        ```
    - ### 闭包 的 主要应用
        - 1.隐藏数据
            - 闭包 隐藏数据，只提供 Api
                ```js
                // 如 做一个简单的 cache 工具

                function createCache () {
                    const data = {}  // 闭包中的数据，被隐藏，不被外部访问
                    return {
                        set: function (key, val) {
                            data[key] = val
                        },
                        get: function (key) {
                            return data[key]
                        }
                    }
                }

                const c = createCache()
                c.set('a', 100)
                console.log( c.get('a') )

                data.b = 200 // 无法访问 Uncaught ReferenceError: data is not defined
                ```
        - 2.模块模式
            ```js
            function fn () {
                const a =  1
                function dosomething () {
                    console.log(a)
                }
                return {
                    dosomething
                }
            }
            const foo = fn()
            foo.dosomething()//1
            ```
        - 3.for循环
          ```js
          for(var i=0; i<5; i++){
            (function(j){
              setTimeout(function(){
                console.log(j)
              }, j*1000)
            })(i)
          }
          ```
        - 4.函数柯里化
          ```js
          function curry(fn){
            const args = [...arguments].slice(1)
            return function(){
                const innerArgs =  [...arguments]
                const finnalArgs = args .concat(innerArgs)
                return fn.apply(null, finnalArgs)
            }
          }
          function add(n1,n2){
            return n1+n2
          }
          curry(add,5)(3)//8
          ```

- ## 4-3 this
    - > this 的取值 **是在函数执行时候确定的**，而不是定义时候 确定的

    - ## this总结（5点）
        - 1.普通函数调用，fn() 里面的 this 就是 window（非严格模式下）
            - fn() 是 strict mode，this 就是 undefined
        - 2.作为对象方法调用，`a.b.c.fn()` 里面的 this 就是 a.b.c
        - 3.在 Class 中调用，new F() 里面的 this 就是新生成的实例
        - 4.箭头函数 this 取值 `() => console.log(this)` ，永远是 它上级作用域的 this
        - 5.使用 `call(), apply(), bind()` 传入什么 this 就指向什么
        - 6.`setTimeout` 的函数内 this 是 window（非严格模式下）
            - 因为 setTimeout, setInterval 这种函数 都是先注册到 事件队列里，等到真正执行的时候 是由 window 来调用的，所以 setTimeout, setInterval 的 this 指向 window
        - 7.当然还有事件监听的时候，this是监听元素

    ```js
    function fn1 () {
      console.log(this)
    }
    fn1() // window

    fn1.call({ x: 100 }) // { x: 100 }

    const fn2 = fn1.bind({ x: 200 })
    fn2() // { x: 200 }
    ```
    ```js
    const zhangsan = {
      name: '张三',
      sayHi () {
        console.log(this) // this 即当前对象
      },
      wait () {
        setTimeout(function () {
          // this === window
          console.log(this)
        }, 0)
      }
    }
    ```  
    ```js
    const zhangsan = {
      name: '张三',
      sayHi () {
        console.log(this) // this 即当前对象
      },
      waitAgain () {
        setTimeout( () => {
          // this 即当前对象
          console.log(this)
        }, 0)
      }
    }
    ```
    ```js
    class People {
      constructor (name) {
        this.name = name
        this.age = 20
      }
      sayHi () {
        console.log(this)
      }
    }

    const zhangsan = new People('张三')
    zhangsan.sayHi() // zhangsan 对象
    ```
    
    - 下面看一道题（作全对，基本this过关）
    ```js
    var app = {
        fn1: function () {
            console.log(this)
        },
        fn2: function(){
            return function() {
                console.log(this)
            }
        },
        fn3: function() {
            function fn() {
                console.log(this)
            }
            return fn()
        },
        fn4: function() {
            return {
                fn: function () {
                    console.log(this)
                }
            }
        },
        fn5: function() {
            setTimeout(function () {
                console.log(this)
            },10) 
        },
        fn6: function() {
            setTimeout( () => {
                console.log(this)
            },20) 
        },
        fn7: function() {
            setTimeout(function () {
                console.log(this)
            }.bind(this),30) 
        },
        fn8: () => {
            setTimeout( () => {
                console.log(this)
            },40) 
        }
    }

    app.fn1()
    app.fn2()()
    app.fn3()
    app.fn4().fn()
    app.fn5()
    app.fn6()
    app.fn7()
    app.fn8()
    ```
    <------------------ 分割线 ------------------>

    ```js
    app.fn1() // app                      +
    app.fn2()() // app                    x window
    app.fn3() // app                      x window
    app.fn4().fn() // undefined           x app
    app.fn5() // window                   +
    app.fn6() // window                   x app
    app.fn7() // app                      +
    app.fn8() // window                   +
    ```

    答案：
    ```js
    app.fn1()//app
    app.fn2()()//window(undefined)
    app.fn3()//window(undefined)
    app.fn4().fn()//app
    app.fn5()//window(undefined)
    app.fn6()//app
    app.fn7()//app
    app.fn8()//window(undefined)
    ```

    链接：https://www.jianshu.com/p/80b273701ab2

    

    - [彻底搞懂JavaScript中的this指向问题 【知乎】](https://zhuanlan.zhihu.com/p/42145138)
    - [彻底理解js中this的指向，不必硬背](https://www.cnblogs.com/pssp/p/5216085.html)
        - > 谁调用的就指向谁
    - [简单快速理解js中的this、call和apply 【掘金】](https://juejin.im/post/6844903576532172813)



- ## [JavaScript 中 call()、apply()、bind() 的用法](https://www.runoob.com/w3cnote/js-call-apply-bind.html)
    - 其实是一个很简单的东西，认真看十分钟就从一脸懵B 到完全 理解！
    - 先看明白下面：
    - **例1：**
        ```js
        var name = '小王', age = 17
        var obj = {
            name: '小张',
            objAge: this.age,
            myFun: function () {
                console.log( this.name + '年龄' + this.age )
            }
        }
        ```
        ```js
        obj.objAge;  // 17
        obj.myFun()  // 小张年龄 undefined
        ```
    - **例2：**
        ```js
        var fav = '盲僧'
        function shows() {
            console.log(this.fav)
        }
        ```
        ```js
        shows()  // 盲僧　
        ```
    - 比较一下 上面 例1 例2 这两者 this 的差别，第一个打印里面的 this 指向 obj，第二个全局声明的 shows() 函数 this 是 window ；
    - ###  **1.call()、apply()、bind() 都是用来重定义 this 这个对象的！**
        ```js
        var name = '小王', age = 17;
        var obj = {
            name: '小张',
            objAge: this.age,
            myFun: function () {
                console.log( this.name + '年龄' + this.age )
            }
        }
        var db = {
            name: '德玛',
            age: 99
        }
        ```
        ```js
        obj.myFun.call(db)；　　　　// 德玛年龄 99
        obj.myFun.apply(db);　　　 // 德玛年龄 99
        obj.myFun.bind(db)();　　　// 德玛年龄 99
        ```
        以上除了 bind 方法后面多了个 () 外 ，结果返回都一致！

        由此得出结论，bind 返回的是一个新的函数，你必须调用它才会被执行。

        > call()、apply()、bind() 都是用来重定义 this 这个对象的！ <br>
        > call()、apply()、bind() 都是 **引用了原函数的结构 (处理逻辑)，但是却使用了新的this** <br>
        > call()、apply()、bind() 都是 **引用了原函数的结构 (处理逻辑)，但是this却指向了传入的对象**
        - 用上面 第3句话，一句话记住 `call()、apply()、bind()` 的用法

        <br>
        <br>

        - 最后再看 [官方定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function)
            - `Function.prototype.call()`
            - 在一个对象的上下文中应用另一个对象的方法；
        - 如何理解？举个例子
            - `obj.myFun.call(db)`
            - 在 db 对象的上下文中，应用 `obj.myFun` 这个方法
    - **2.对比call 、bind 、 apply 传参情况下**
        ```js
        var name = '小王', age = 17;
        var obj = {
            name: '小张',
            objAge: this.age,
            myFun: function (fm, t) {
                console.log( this.name + '年龄' + this.age, ' 来自 ' + fm + '去往' + t )
            }
        }
        var db = {
            name: '德玛',
            age: 99
        }
        ```
        ```js
        obj.myFun.call(db,'成都','上海')；　　　　 // 德玛 年龄 99  来自 成都去往上海
        obj.myFun.apply(db,['成都','上海']);      // 德玛 年龄 99  来自 成都去往上海  
        obj.myFun.bind(db,'成都','上海')();       // 德玛 年龄 99  来自 成都去往上海
        obj.myFun.bind(db,['成都','上海'])();　　 // 德玛 年龄 99  来自 成都, 上海去往 undefined
        ```
        微妙的差距！

        从上面四个结果不难看出:

        call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象，第二个参数差别就来了：

        call 的参数是直接放进去的，第二第三第 n 个参数全都用逗号分隔，直接放到后面 `obj.myFun.call(db,'成都', ... ,'string' )`。

        apply 的所有参数都必须放在一个数组里面传进去 `obj.myFun.apply(db,['成都', ..., 'string' ])`。

        bind 除了返回是函数以外，它 的参数和 call 一样。

        当然，三者的参数不限定是 string 类型，允许是各种类型，包括函数 、 object 等等！