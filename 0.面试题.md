# 快速搞定前端初级 JavaScript 面试
- 慕课网 ( 双越 老师 )

<br><br>

# 高效学习三步曲
    - 1.找准知识体系
    - 2.刻意练习
    - 3.及时反馈

- 知识体系：结构化的知识范围
- 涵盖所有知识点；结构化、有组织、易扩展

> 要进一线互联网公司，js基础知识 一定要 一定要 扎实

----
目录
- [第01章 课程介绍【说说面试的那些事儿】](#第01章-课程介绍【说说面试的那些事儿】)
    - [1 课程介绍](#1-课程介绍)
    - [1-3 几个面试题](#1-3-几个面试题)
    - [1-5 知识体系](#1-5-知识体系)
    - [知识体系 细分](#-知识体系-细分)
- [第02章 JS基础-变量类型和计算【不会变量，别说你会JS】](#第02章-JS基础-变量类型和计算【不会变量，别说你会JS】)
    - [2-1 值类型 和 引用类型](#2-1-值类型-和-引用类型)
    - [2-2 typeof 和 深拷贝](#2-2-typeof-和-深拷贝)
        - [typeof 运算符](#typeof-运算符)
        - [null 是对象吗？](#null-是对象吗？)
        - [判断数据类型](#判断数据类型)
        - [NaN === NaN false?](#NaN-===-NaN-false?)
        - [深拷贝](#深拷贝)
    - [2-3 变量计算 - 隐式类型转换](#2-3-变量计算---隐式类型转换)
        - [字符串拼接](#字符串拼接)
        - [== 运算符](#==-运算符)
        - [truly 变量 和 falsely 变量](#truly-变量-和-falsely-变量)
        - [if 语句](#if-语句)
        - [逻辑运算](#逻辑运算)
- [第03章 JS基础-原型和原型链【三座大山之一，必考！！！】](#第03章-JS基础-原型和原型链【三座大山之一，必考！！！】)
    - [3-1 题目和知识点](#3-1-题目和知识点)
    - [3-2 class和继承](#3-2-class和继承)
        - [Class](#Class)
        - [继承](#继承)
    - [3-3 原型](#3-3-原型)
    - [3-4 原型链和instanceof](#3-4-原型链和instanceof)
    - [3-5 问题解答和总](#3-5-问题解答和总)
- [第04章 JS基础-作用域和闭包【三座大山之二，不会闭包，基本不会通过】](#第04章-JS基础-作用域和闭包【三座大山之二，不会闭包，基本不会通过】)
    - []()
    - []()
    - []()
    - []()
    - []()
    - []()
    - []()
- [第05章 JS基础-异步【三座大山之三，必考！！！】](#第05章-JS基础-异步【三座大山之三，必考！！！】)
    - [5-1 同步和异步的区别](#5-1-同步和异步的区别)
    - [5-2 应用场景](#5-2-应用场景)
    - [5-3 promise](#5-3-promise)
    - [5-4 问题解答和总结](#5-4-问题解答和总结)
    - [5-5 JS基本知识-总结](#5-5-JS基本知识-总结)
- [第06章 JS-Web-API-DOM【学会DOM，才能具备网页开发的基础】](#第06章-JS-Web-API-DOM【学会DOM，才能具备网页开发的基础】)
    - []()
- [第07章 JS-Web-API-BOM【内容虽然不多，但是你不能不会】](#第07章-JS-Web-API-BOM【内容虽然不多，但是你不能不会】)
- [第08章 JS-Web-API-事件【事件不会，基本等于半残废，必考！必考！】](#第08章-JS-Web-API-事件【事件不会，基本等于半残废，必考！必考！】)
- [第09章 JS-Web-API-Ajax【每个工程师必须熟练掌握的技能】](第09章-JS-Web-API-Ajax【每个工程师必须熟练掌握的技能】)
- [第10章 JS-Web-API-存储【内容虽然不多，但不可不会】](#第10章-JS-Web-API-存储【内容虽然不多，但不可不会】)
- [第11章 开发环境【不会这些，你就会被认定是菜鸟小白，没做过项目】](#第11章-开发环境【不会这些，你就会被认定是菜鸟小白，没做过项目】)
- []()
- []()
- []()
- []()
- []()
- []()

----

- [JavaScript基础面试题受益匪浅（转）](https://zhuanlan.zhihu.com/p/79547341)
- [JS基础知识（覆盖JS基础面试题）](https://juejin.im/post/6844903625618096141)

----
# 第01章 课程介绍【说说面试的那些事儿】
- ## 1 课程介绍
- 主要知识点
    - ES6 Class
    - Promise
    - 模块化
    - 手写代码题
    - webpack (最新版)
    - babel (最新版)
- 做什么？-- 讲解前端基础面试题
- 哪些部分？-- 基础知识，JS Web Api ，开发环境，运行环境
- 技术？-- 原型，作用域，异步，Ajax，事件，Webpack 等

- 基础知识
    - 原型，原型链
    - 作用域，闭包
    - 异步，单线程
- API
    - DOM，BOM
    - Ajax，跨域
    - 事件，存储
- 开发环境
    - 版本管理
    - 调试，抓包
    - 打包构建
- 运行环境
    - 页面渲染
    - 性能优化
    - Web安全

- ## 1-3 几个面试题
    ```
    1.typeof 能判断哪些类型？

    2.何时使用 === ，何时使用 ==

    3.window.onload 和 DOMContentLoaded 的区别？

    4.JS 创建10个 <a> 标签，点击的时候弹出对应的序号

    5.手写节流 throttle、防抖 debounce

    6.Promise 解决了什么问题？
    ```
    - 问题：
        - 拿到一个面试题，你第一时间 看到的是什么？
        - 如何看待网上搜出来的 永远做不完的题海？
        - 如何对待接下来遇到的面试题？
    - 答：
        - 考点
        - 不变应万变 （题可变，考点不变）
        - 题目到知识点，再到题目

    ```
    1.typeof 能判断哪些类型？
        - 考点：js变量类型
            - 基本类型 和 引用类型的区别
            - 深拷贝，浅拷贝
            - 怎么判断 一个东西 是不是对象

    2.何时使用 === ，何时使用 ==
        - 考点：隐式类型转换

    3.window.onload 和 DOMContentLoaded 的区别？
        - 考点：页面加载过程
            - 为啥 css 要放在 head 里，为啥 js 要放在 最底下

    4.JS 创建10个 <a> 标签，点击的时候弹出对应的序号
        - 考点：作用域
            - this 指向
            - 闭包

    5.手写节流 throttle、防抖 debounce
        - 考点：性能、体验优化

    6.Promise 解决了什么问题？
        - 考点：JS异步
            - 异步 和 同步 有什么区别
            - 为什么有异步？
            - 异步的应用场景是什么？它在什么地方用？
            - 定时器 该如何使用？
    ```
    - 答：
        - 1.typeof 能判断哪些类型？
            - string number booleam undefined null symbol
            - object ( Array[] , Object{} )
            - function
        - 2.何时使用 === ，何时使用 ==
            - 允许 隐式类型转换 的情况下，可以用 ==
            - 其他情况下 用 ===

## 1-5 知识体系

## 前端知识体系怎么梳理？
- ### **W3C 标准**
    - Html、Css、DOM操作、BOM操作、Ajax、事件绑定
- ### **ECMA 262 标准**
    - 规定 JS 语法标准
        - 变量定义、if else、function定义、原型方式、闭包方式、Promise
- ### 开发环境
    - 代码版本管理、调试、打包上线
- ### 运行环境
    - 加载、性能优化、安全

<br><br>

## 知识体系
- ### 基础语法
    - 变量定义、变量类型判断、逻辑运算、函数定义、原型、闭包、Promise、Class...
- ### JS-Web-API
    - 网页请求、点击事件...
    - 获取网页元素、获取浏览器URL、BOM操作、DOM操作...
- ### 开发环境
    - 代码版本管理、调试、打包上线、代码的架构设计方式
- ### 运行环境
    - 加载、性能优化、安全

<br><br>

## 知识体系 细分
- ### ① JS基础知识
    - 变量类型和计算
        - 值类型 和 引用类型
        - 类型判断
        - 逻辑运算
    - 原型和原型链
        - Class
        - 继承
        - 原型
        - 原型链
        - instanceof
    - 作用域和闭包
        - 作用域
        - 自由变量
        - 闭包
        - this
    - 异步
        - 单线程
        - callback
        - 应用场景
        - Promise
    - 模块化
        - ES6 Module
- ### ② JS-Web-API
    - DOM
        - 树形结构
        - 节点操作
        - 属性
        - 树结构操作
        - 性能
    - BOM
        - navigator
        - screen
        - location
        - history
    - 事件
        - 绑定
        - 冒泡
        - 代理
    - ajax
        - XMLHttpRequest
        - 状态码
        - 跨域
    - 存储
        - cookie
        - localStorage
        - sessionStorage
- ### ③ 开发环境
    - git
    - 调试
    - webpack 和 babel
    - linux命令
- ### ④ 运行环境
    - 页面加载
        - 加载
        - 渲染
    - 性能优化
        - 加载资源优化
        - 渲染优化
    - 安全
        - xss
        - CSRF

<br>

- ### 特别提醒
    - 这仅仅是符合本课程目标和范围的知识体系
    - 并不是所有前端的知识体系,如没有vue React nodejs等
    - 知识体系也是有层次的,要循序渐进

----



# 第02章 JS基础-变量类型和计算【不会变量，别说你会JS】

## 2-1 值类型 和 引用类型
题目 -> 知识点 -> 解答
- 当你看到 考点时，如果你就能想得到 应该出哪些题 来考察候选人，这才是 见基本功，见能力 的事情

```
- 题目
    - typeof 能判断哪些类型
    - 何时使用 === ，何时使用 ==
    - 值类型 和 引用类型 的区别
    - 手写深拷贝 （涉及 递归）
```
- 知识点
    - 值类型 vs 引用类型
    - typeof 运算符
    - 深拷贝
        - 为什么 js 默认只支持 浅拷贝，不支持 深拷贝？

- 值类型
    ```js
    let a = 20;
    let b = a;
    b = 30;
    console.log(a); // 20
    ```
    ![](./img/0.interview-question/2.jpg)
- 引用类型
    ```js
    let m = { a: 10, b: 20 };
    let n = m;
    n.a = 15;
    console.log(m.a) // 15
    ```
    ![](./img/0.interview-question/3.jpg)
- 值类型 和 引用类型 的区别
    - 值类型 直接保存在 "栈区 Stack"，而 引用类型 是在栈里保存 堆地址，堆地址指向 "堆Heap" 内存 保存的内容。
    - 值类型 都是各自独立保存的，不会互相干扰。引用类型 有可能会互相干扰

- 为什么？
    - 为什么 值类型 可以直接把 数据保存了
    - 而 引用类型 却要先保存 堆地址，然后再用 堆地址 指向 堆内存中的数据？
    - 为什么 引用类型 不能直接保存数据？

- 因为
    - **值类型** 占用空间比较小，可以直接赋值，而且 赋值操作的时候 也不会对性能 造成什么影响
    - **引用类型** 占用空间 可以很大很大，在复制 的时候 可能由于 数据内容太大 而影响性能
    - 他是因为基于 内存的空间 和 CPU计算的耗时 来做的这种区分

- 常见值类型
    ```js
    const a // 报错 Uncaught SyntaxError: Missing initializer in const declaration

    let a // undefined
    const s = 'abc'
    const n = 100
    const b = true
    const s = Symbol('s')
    ```
    - 注意：如果 使用 `const` 时，没有赋值 会直接报错

- 常见 引用类型
    ```js
    const obj = { x:100 }
    const arr = ['a', 'b', 123]

    // 特殊引用类型, 但不用于存储数据，所以没有 "拷贝，复制函数" 这一说
    function fn () {}
    ```

## 2-2 typeof 和 深拷贝
- ## typeof 运算符
    - typeof 能区分的类型
        - 能区分所有值类型
        - 识别函数
        - 判断是否是引用类型 （不可在细分）
    ```js
    // typeof 能判断所有值类型, 除了 null
    let a;                      typeof a   // 'undefined'
    const str = 'abc';          typeof str // 'string'
    const n = 100;              typeof n   // 'number'
    const b = true;             typeof b   // 'boolean'
    const s = Symbol('s');      typeof s   // 'symbol'
    ```
    ```js
    // typeof 能判断函数
    typeof console.log  // 'function'
    typeof function(){} // 'function'

    // typeof 能判断 引用类型 （不可在细分）
    typeof null        // 'object'
    typeof ['a', 'b']  // 'object'
    typeof { x: 100 }  // 'object'
    ```

- ## null 是对象吗？
    - 先来看现象
    ```js
    typeof null // object
    ```
    - what ?  `null` 是 对象 ？？？ `null` 不是基本类型吗？

    <br>

    - [值 null 特指对象的值未设置。它是 JavaScript 基本类型 之一](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null)
    - [`typeof null` 返回 `object` **似乎是历史遗留的bug**](https://github.com/YvetteLau/Step-By-Step/issues/5)
    - [Null is not an object in JavaScript! typeof null === 'object' but that's a bug! ](https://stackoverflow.com/questions/801032/why-is-null-an-object-and-whats-the-difference-between-null-and-undefined)
        - [Here's a link Watch all the videos and enjoy :)](https://www.youtube.com/watch?v=JxAXlJEmNMg)
    ```js
    Object.prototype.toString.call(null)  // "[object Null]"
    ```

- ## [判断数据类型](https://www.jianshu.com/p/585926ae62cc)
    - `typeof null || Object.prototype.toString.call(null) `
    - `Object.prototype.toString.call()` 永远能够正确判断 正确的数据类型
    - **typeof**
        - `typeof` 判断数据类型，只能区分基本类型，即：`number`、`string`、`undefined`、`boolean`、`symbol`、`object`。
        - 对于 `null`、`array`、`function`、`object`来说，使用 `typeof` 都会统一返回 `object` 字符串。
    - `Object.prototype.toString.call()`
        - 要想区分对象、数组、函数、单纯使用typeof是不行的。在JS中，可以通过 `Object.prototype.toString` 方法
        - 可以区分
            - 基本类型 `null`、`string`、`boolean`、`number`、`undefined`、`null`
            - 复杂类型 `array`、`object`、`function`
            - 还可以区分 `date`、`math`、`RegExp`、`JSON`
        ```js
        Object.prototype.toString.call(null); // "[object Null]"
        Object.prototype.toString.call(undefined); // "[object Undefined]"
        Object.prototype.toString.call(“abc”);// "[object String]"
        Object.prototype.toString.call(123);// "[object Number]"
        Object.prototype.toString.call(true);// "[object Boolean]"
        ```
        ```js
        // **函数类型**
        Function fn(){
            console.log(“test”);
        }
        Object.prototype.toString.call(fn); // "[object Function]"
        ```
        ```js
        // **正则表达式**
        var reg = /[hbc]at/gi;
        Object.prototype.toString.call(reg); // "[object RegExp]"
        ```
        ```js
        // **日期类型**
        Object.prototype.toString.call(new Date()) // "[object Date]"
        ```
        ```js
        Object.prototype.toString.call(Math) // "[object Math]"

        Object.prototype.toString.call(JSON) // "[object JSON]"

        Object.prototype.toString.call([1]) // "[object Array]"
        Object.prototype.toString.call({})  // "[object Object]"
        ```
        ```js
        // **自定义类型**
        function Person (name, age) {
            this.name = name
            this.age = age
        }
        var person = new Person('Rose', 18)
        Object.prototype.toString.call(person) // "[object Object]"
        ```
        - 很明显这种方法不能准确判断 `person` 是 `Person` 类的实例，而只能用 `instanceof` 操作符来进行判断，如下所示：
        ```js
        console.log(person instanceof Person); // true
        ```
- ## NaN === NaN false?
    先来看一个现象
    ```js
    NaN == NaN  //false
    NaN === NaN // false
    ```
    - [Why is NaN === NaN false? ](https://stackoverflow.com/questions/19955898/why-is-nan-nan-false)
        - Because Not a Number is not a number, and is not equal to anything, including Not a Number

    <br>
    
    ```js
    typeof NaN // "number"

    Object.prototype.toString.call(NaN) // "[object Number]"
    ```
    - 虽然 用上面的类型判断，都返回 `number` ，但实际上 他不是一个 `number`，
    - 而且 `NaN` 不等于任何东西

- ## 深拷贝
    - 手写 深拷贝 的 考点：
        - 基本类型 和 引用类型
        - 递归
        - 要求手写，就是做考察 逻辑是否清晰
    ```js
    function deepClone ( obj={} ) {
        if ( typeof obj !== 'object' || obj == null ) {
            // obj 是 null，或者不是对象和数组，直接返回
            return obj
        }

        // 初始化返回结果
        // 如果 obj 是数组，就用 [] 包裹；如果 obj 是对象，就用 {} 包裹
        let result
        if (obj instanceof Array) {
            result = []
        } else {
            result = {}
        }

        for (let key in obj) {
            // 保证 key 不是原型链的属性
            if (obj.hasOwnProperty(key)) {
                // 递归调用！！！
                result[key] = deepClone(obj[key])
            }
        }

        // 返回结果
        return result
    }
    ```
    - 深拷贝思路：
        - 注意判断值的类型。如果是基本类型 就直接返回；如果是 引用类型 就递归
        - 注意判断是 数组 还是 对象
        - 递归

    ```js
    // 测试用例
    const obj1 = {
        age: 20,
        name: 'xxx',
        address: {
            city: 'beijing',
            a: {
                x: {
                    y: 'yName',
                    arr: [
                        {x: 1},
                        [1, 3, 6]
                    ],
                    reg: /\d/gi,
                    fn2: function(){ console.log('this is function2') },
                }
            }
        },
        fn: function(){ console.log('this is function') },
        arr: ['a', 'b', 'c']
    }

    const obj2 = deepClone(obj1)
    obj2.address.city = 'New York'
    console.log(obj2.address.city)
    console.log(obj1)
    console.log(obj2)
    console.log(obj2.fn(), obj2.address.a.x.fn2())
    
    ```

## 2-3 变量计算 - 隐式类型转换
```
- 有3种情况 最容易发生 隐式类型转换

    - 字符串拼接
    - ==
    - if 语句和逻辑运算
```

- ### **字符串拼接**
    - 字符串拼接，是最容易发生 隐式类型转换 的场景之一
    - > `'字符串'` 和任何东西 相加 `+`，就有可能发生 **`字符串拼接`**
    ```js
    // 基本类型
    const a = 100 + 10      // 110
    const b = '100' +　'10' // "10010"
    const c = 100 + '10'    // '10010'
    const d = true + '10'   // 'true10'
    const e = undefined + '10' // "undefined10"
    const f = null + '10'   //"null10"

    // 复杂类型
    const g = [1] + '12'    // "112"
    const h = {a:2} + '12'  // 12
    function fn(){} + '12'  // 12


    Symbol('1') + '12'   // Uncaught TypeError: Cannot convert a Symbol value to a string
    ```
    > 总结： <br>
    >   - `'字符串'` 和任何东西 相加 `+`，都会优先发生 **`字符串拼接`** <br>
    >   - 如果实在没办法 发生 `字符串拼接`，才会 隐式转换成 **`数学运算`** <br>
    >   - `Symbol()` 和任何东西 相加 `+`，都会报错
    ```js
    // 多类型 混合运算

    {a:2} + '12' + '1'　+ 1 + null + true + undefined +　[9]
    // "1211nulltrueundefined9"

    [9] + {a:2} + '12' + '1'　+ 1 + null + true + undefined
    // "9[object Object]1211nulltrueundefined"

    {a:2} + '12' + '1'　+ 1 + null + true + undefined + function fn(){}
    // "[object Object]1211nulltrueundefinedfunction fn(){}"

    {a:2} + '12' + '1'　+ 1 + null + true + undefined + function fn(){} + Symbol(1)
    // Uncaught TypeError: Cannot convert a Symbol value to a string
    ```
    - **显示转换**
        - 某些情况下，如果不能确定 传入的数据类型，可以先 **显示转换** 然后再进行运算，如
        ```js
        100 + parseInt('10') // 100
        ```

- ### **`==` 运算符**
    - **`==` 运算符**, 是最容易发生 隐式类型转换 的场景之一
    > **`==` 运算符**, 会优先 **尽量尝试** 让他们转换类型之后，再判断 他们是否相等
    ```js
    100 == '100' // true
    0 == ''      // true
    0 == false   // true
    false == ''  // true
    null == undefined // true
    ```
    - 如果不希望 发生 **`隐式类型转换`**
        - 那么除了 `== null` 之外，其他情况 都一律用 `===`, 例如：
        ```js
        const obj = { x: 100 }
        if ( obj.a == null ) { }

        // 相当于：
        if ( obj.a === null || obj.a === undefined ) { }
        ```
        > `( obj.a == null ) ` 等价于 ` ( obj.a === null || obj.a === undefined )` <br>
        > 在很多 知名项目中 都是这么用的，如 jQuery, EsLint...

- ### **`truly 变量`** 和 **`falsely 变量`**
    - **`truly 变量`**: `!!a === true` 的变量
    - **`falsely 变量`**: `!!a === false` 的变量
    > 经过两次 **`!` 非运算**，如果等于 `true` 就是 **`truly 变量`**，如果等于 `false` 就是 **`falsely 变量`**
    ```js
    const n = 100
    !n  // false
    !!n // true
    // 所以 100 属于 truly变量

    const m = 0
    !m  // true
    !!m // false
    // 所以 0 属于 falsely变量
    ```
    - 以下 **`6种情况`** 是 falsely 变量。除此之外都是 truly 变量
        > 除了 **`5种基本类型，加上 NaN`** 双取反 为 falsely 变量 之外，其他都是 truly 变量
        ```js
        !!0 === false
        !!'' === false
        !!false == false
        !!undefined === false
        !!null === false
        !!NaN === false
        ```
- ### **`if` 语句**
    > 实际上 **`if` 语句** 判断的就是 **`truly 变量`** 和 **`falsely 变量`**，而不是判断 true or false
    ```js
    // truly 变量
    const a = true
    if (a) {}

    const b = 100
    if (b) {}
    ```
    ```js
    // falsely 变量
    const c = ''
    if (c) {}

    const d = null
    if (d) {}

    let e
    if (e) {}
    ```

- ### **逻辑运算**
    - [现代 JavaScript 教程 — 逻辑运算符](https://juejin.im/post/6844903991139123208)
    - 逻辑运算符
        - JavaScript 里有三个逻辑运算符：`||`（或），`&&`（与），`!`（非）
        > `||` 或运算 寻找第一个真值<br>
        > `&&` 与操作 寻找第一个假值<br>
        > `!` &nbsp; 非操作 取反
        
        > `||` 或运算 寻找第一个真值，或返回最后一个 falsely 变量 <br>
        > `&&` 与操作 寻找第一个假值，或返回最后一个 truly 变量<br>
        > `!` &nbsp; 非操作 取反

        > `||` 或运算 返回第一个真值，或返回最后一个假值 <br>
        > `&&` 与操作 返回第一个假值，或返回最后一个真值<br>
        > `!` &nbsp; 非操作 取反
    ```js
    10 && 0     // 0
    '' || 'abc' // 'abc'
    !window.abc // true
    ```


# 第03章 JS基础-原型和原型链【三座大山之一，必考！！！】
## 3-1 题目和知识点
- 原型和原型链
    - 原型和原型链 是js比较重要的 知识点，必考！
    - 如果面试中，不考原型和原型链，要么面试官是煞笔，要么这个岗位非常不重要
- 为什么 原型和原型链 重要？
    - 因为 js本身 就是 **`基于原型继承`** 的语言
    - 在 ES6 之前，**`继承`** 只能通过 **`原型继承`**。不像别的语言，如 JAVA 能通过 Class 来继承
    - ES6 时，js 才有了 Class 的方法来继承
        - 但是经过破解发现，ES6 的 Class 只是形式上实现了 Class 的写法而已，本质上的继承 还是 原型继承
```
- 题目
    - 1.如何准确判断一个变量是不是 数组？
        - x instanceof Array
        - 那么问题来了：这个 instanceof 到底是怎么判断出来 它到底是不是数组 ？ 这是一个值得思考的问题

    - 2.手写一个简易的 jQuery，考虑插件和扩展性
        - jQuery 慢慢变得不常用了。但是 学习 jQuery 的设计方式，学习 js基础知识，可以类比 我们本节要学习的原型 这部分内容，让我们更容易理解 原型

    - 3.Class 的原型本质，怎么理解？
        - 这个问题 比较偏概念
        - 但是 越是偏概念的问题，就越是能 考察你对基础知识的理解能力，你能不能 通过自己的语言 把这些知识表述出来 (或 通过画图的方式 讲事情讲解清楚)。
```


## 3-2 class和继承
- ## Class
    - ### 什么是 Class
        - Class 是面向对象的一个语法实现
    - ### Class 内有什么
        - constructor 构建函数
        - 属性
        - 方法

    ```js
    class Student {
        constructor (name, number) {
            // this 指向 你当前正在构建的实例
            this.name = name // 属性
            this.number = number
            this.gender = 'male'
        }
        sayHi () { // 方法
            console.log( `姓名 ${this.name}, 学号 ${this.number}` )
        }
    }

    // 通过类声明 对象/实例
    const xialuo = new Student('夏洛', 100)  // `new Student()` 时，就会走 `constructor()` 构建函数，来生成对象

    console.log(xialuo.name)
    console.log(xialuo.number)
    xialuo.sayHi()
    ```
    - `new Student()` 时，就会走 `constructor()` 构建函数，来生成对象

- ## 继承
    - ### 什么是继承？
        - 打个比方：
            - 现在已有 人、老师、学生 这3个分类 Class
            - 老师和学生 都是属于人 这个分类
            - 而人都有一个共性，比如 都有吃的方法，都有说话的方法
            - 现在我需要创建一个新的职业，如 司机。但是如果我重新开始写 吃 和 说话的方法 又太麻烦了，而且这些方法 人这个分类本来就有。那我现在 直接通过 人这个分类 直接继承过来，就好了
            - 这就是 继承
            - 然后把 司机 自己特有的属性和方法 再加到 司机这个 类Class 上就可以了
    - ### 继承里有什么？
        - extends
        - super
            - 通过 `super()` 执行父类的 `constructor()`
        - 扩展或重写方法
    ```js
    // 父类
    class People {
        constructor (name) {
            this.name = name
        }
        eat () {
            console.log(`${this.name} eat something`)
        }
    }

    // 子类
    class Student extends People {
        constructor (name, number) {            
            super(name) // 通过 `super()` 执行父类的 `constructor()`
            this.number = number
        }
        sayHi () {
            console.log(`姓名 ${this.name} 学号 ${this.number}`)
        }
    }

    // 子类
    class Teacher extends People {
        constructor (name, major) {
            super(name)
            this.major = major
        }
        teach () {
            console.log(`${this.name} 教授 ${this.major}`)
        }
    }

    // 实例
    const xialuo = new Student('夏洛', 100)
    console.log(xialuo.name)
    console.log(xialuo.number)
    xialuo.sayHi()
    xialuo.eat()

    const wanglaoshi = new Teacher('王老师', '语文')
    console.log(wanglaoshi.name)
    console.log(wanglaoshi.major)
    wanglaoshi.teach()
    wanglaoshi.eat()

    ```

## 3-3 原型
- ### 类型判断 - instanceof 
    - instanceof 可以判断 这个变量 是属于哪个 `Class` 或 `构造函数`
    ```js
    xialuo instanceof Student // true
    xialuo instanceof People  // true
    xialuo instanceof Object  // true

    [] instanceof Array  // true
    [] instanceof Object // true

    {} instanceof Object // true
    ```
- ### 原型
    ```js
    // js 里的 Class 实际上是函数，可见是语法糖
    typeof People  // 'function'
    typeof Student // 'function'
    ```
    > js 里的 Class继承 实际上是函数继承，不像 java 这种真正的 纯Class 的继承 <br>
    > 而是像 js里的这种 原型继承 <br>
    > 可见 js里的 Class 只是一种语法糖。写法是 Class 的写法，但实际上 是 js的原型继承


-----


明天继续！！！从这里

----


## 3-4 原型链和instanceof
## 3-5 问题解答和总

# 第04章 JS基础-作用域和闭包【三座大山之二，不会闭包，基本不会通过】
- ## 4-1 作用域和自由变量
    - 先看题
        ```
        this 的不同应用场景，如何取值？

        手写 bind 函数

        实际开发中闭包的应用场景，举例说明

        创建 10 个 a 标签，点击的时候 弹出对应的序号
        ```
        - 题目解析
            - bind 函数 是改变 this 指向 的方法之一
            - 考察点：1.看你会不会用bind 函数，2.看你手写的逻辑是否清晰
    - 手写 bind 函数
        ```js
        Function.prototype.bind1 = function () {
            // 将参数解析为数组
            const args = Array.prototype.slice.call(arguments)
            // 获取 this ( 取出数组第一项，数组剩余的就是传递的参数 )
            const t = args.shift()
            const self = this // 当前函数
            // 返回一个函数
            return function () {
                // 执行原函数，并返回结果
                return self.apply(t, args)
            }
        }
        ```
        - `arguments` 可以获取 所有传入的参数。但是他是一个 列表，不是数组，所以这里把他转为数组
            - `const args = Array.prototype.slice.call(arguments)` 通过这种方式 就可以把 列表变为 数组
    - 创建 10 个 a 标签，点击的时候 弹出对应的序号
        ```js
        let i, a
        for (i = 0; i < 10; i++) {
            a = document.createElement('a')
            a.innerHTML = i+'<br>'
            a.addEventListener('click', function(e){
                e.preventDefault()
                alert(i)
            })
            document.body.appendChild(a)
        }
        ```
        - > 弹出来的 都是 10 ？？？
        - 问题分析：
            - 上面 i 和 a 都是全局变量
            - `for 循环` 本质上是创建了 多个 `{}` 块级代码
            - 如果 变量的作用域在 `{}` 块级代码内，那就能够达到预期的效果
        - 这个问题有两个解法
            ```js
            // 解法一：利用块级作用域，将 i 的作用域 放在 `{}` 块级代码内
            
            let a
            for ( let i=0; i<10; i++) {
                a = document.createElement('a')
                a.innerHTML = i + '<br>'
                a.addEventListener('click', function(e){
                    e.preventDefault()
                    alert(i)
                })
                document.body.appendChild(a)
            }
            ```
            ```js
            // 解法二：将变量放在 函数作用域内

            for(var i=0;i<10;i++){

                (function(i){
                    var a=document.createElement('a');

                    a.innerHTML=i+'<br>';

                    document.body.appendChild(a);

                    a.addEventListener('click',function(e){
                        e.preventDefault();  //取消默认事件，指a标签
                        alert(i);
                    });

                })(i);

            }
            ```
    - 前言：为什么要学？作用域和闭包
        - 面试过程中 如果 `作用域和闭包` 过不了的话，这个人我是不会要的
        - 如果 `作用域和闭包` 搞不清楚，在项目中 模块间相互调用，会产生 比较复杂的关系
        - 你如果这些关系屡不清，关系的作用域的问题，我是肯定不能要你的。要你来 写的代码 不知不觉 就会写出很多BUG 来
    - ### 作用域
        - 作用域 是什么？
            > **作用域就是一个变量的合法使用范围**

        ![](./img/0.interview-question/1.jpg)
        - #### 作用域 有三种
            ```
            全局作用域

            函数作用域

            块级作用域 (ES6新增)
            ```
            - 块级作用域
                ```js
                // ES6 块级作用域
                if (true) {
                    let x = 100
                }
                console.log(x) // 会报错
                ```
                `if , for , while ...` 后面的 `{}` 内都属于块级作用域
    - ### 自由变量
        - 自由变量 是什么？
            > 一个变量在当前作用域没有被定义，但被使用了
        - 向上级作用域，一层一层一次寻找，直到找到为止
        - 如果到全局作用域 都没找到，就会报错 xx is not defined
- ## 4-2 闭包
    - 1.下面代码的输出是什么？
        ```js
        function create () {
            const a = 100
            return function () {
                console.log(a)
            }
        }

        const fn = create()
        const a = 200
        fn()
        ```
        ```js
        function print (fn) {
            const a = 200
            fn()
        }

        const a = 100
        function fn () {
            console.log(a);
        }

        print(fn)
        ```
        - 答案：都是 100

    - **闭包：自由变量的查找，是在函数定义的地方查找，而不是在函数执行的地方！！！**
    - ### 什么是闭包？
        - **闭包是作用域应用的特殊情况**，有两种表现：
            - > 函数作为返回值
            - > 函数作为参数被传递
    - [闭包 定义2](https://www.jianshu.com/p/80b273701ab2)：

        用高程里面的话说就是

        **有权访问另一个函数作用域中的变量的函数**

        其实是一个特别简单的东西，却被搞的好像很复杂。我们平时写得代码里经常写闭包。比如

        **我想把1存起来，下次调用的时候再打印出来**，由于作用域链的关系，fn()之后匿名函数还引用着a,所以a不会被清理掉，下次调用的时候就会打印出来了。
        ```js
        function fn(a){
            return  function(){
                console.log(a)
            }
        }
        fn(1)()//1
        ```
    - ### 闭包 的 主要应用
        - 1.隐藏数据
            - 闭包 隐藏数据，只提供 Api
                ```js
                // 如 做一个简单的 cache 工具

                function createCache () {
                    const data = {}  // 闭包中的数据，被隐藏，不被外部访问
                    return {
                        set: function (key, val) {
                            data[key] = val
                        },
                        get: function (key) {
                            return data[key]
                        }
                    }
                }

                const c = createCache()
                c.set('a', 100)
                console.log( c.get('a') )

                data.b = 200 // 无法访问 Uncaught ReferenceError: data is not defined
                ```
        - 2.模块模式
            ```js
            function fn () {
                const a =  1
                function dosomething () {
                    console.log(a)
                }
                return {
                    dosomething
                }
            }
            const foo = fn()
            foo.dosomething()//1
            ```
        - 3.for循环
          ```js
          for(var i=0; i<5; i++){
            (function(j){
              setTimeout(function(){
                console.log(j)
              }, j*1000)
            })(i)
          }
          ```
        - 4.函数柯里化
          ```js
          function curry(fn){
            const args = [...arguments].slice(1)
            return function(){
                const innerArgs =  [...arguments]
                const finnalArgs = args .concat(innerArgs)
                return fn.apply(null, finnalArgs)
            }
          }
          function add(n1,n2){
            return n1+n2
          }
          curry(add,5)(3)//8
          ```

- ## 4-3 this
    - > this 的取值 **是在函数执行时候确定的**，而不是定义时候 确定的

    - ## this总结（5点）
        - 1.普通函数调用，fn() 里面的 this 就是 window（非严格模式下）
            - fn() 是 strict mode，this 就是 undefined
        - 2.作为对象方法调用，`a.b.c.fn()` 里面的 this 就是 a.b.c
        - 3.在 Class 中调用，new F() 里面的 this 就是新生成的实例
        - 4.箭头函数 this 取值 `() => console.log(this)` ，永远是 它上级作用域的 this
        - 5.使用 `call(), apply(), bind()` 传入什么 this 就指向什么
        - 6.`setTimeout` 的函数内 this 是 window（非严格模式下）
            - 因为 setTimeout, setInterval 这种函数 都是先注册到 事件队列里，等到真正执行的时候 是由 window 来调用的，所以 setTimeout, setInterval 的 this 指向 window
        - 7.当然还有事件监听的时候，this是监听元素

    ```js
    function fn1 () {
      console.log(this)
    }
    fn1() // window

    fn1.call({ x: 100 }) // { x: 100 }

    const fn2 = fn1.bind({ x: 200 })
    fn2() // { x: 200 }
    ```
    ```js
    const zhangsan = {
      name: '张三',
      sayHi () {
        console.log(this) // this 即当前对象
      },
      wait () {
        setTimeout(function () {
          // this === window
          console.log(this)
        }, 0)
      }
    }
    ```  
    ```js
    const zhangsan = {
      name: '张三',
      sayHi () {
        console.log(this) // this 即当前对象
      },
      waitAgain () {
        setTimeout( () => {
          // this 即当前对象
          console.log(this)
        }, 0)
      }
    }
    ```
    ```js
    class People {
      constructor (name) {
        this.name = name
        this.age = 20
      }
      sayHi () {
        console.log(this)
      }
    }

    const zhangsan = new People('张三')
    zhangsan.sayHi() // zhangsan 对象
    ```
    
    - 下面看一道题（作全对，基本this过关）
    ```js
    var app = {
        fn1: function () {
            console.log(this)
        },
        fn2: function(){
            return function() {
                console.log(this)
            }
        },
        fn3: function() {
            function fn() {
                console.log(this)
            }
            return fn()
        },
        fn4: function() {
            return {
                fn: function () {
                    console.log(this)
                }
            }
        },
        fn5: function() {
            setTimeout(function () {
                console.log(this)
            },10) 
        },
        fn6: function() {
            setTimeout( () => {
                console.log(this)
            },20) 
        },
        fn7: function() {
            setTimeout(function () {
                console.log(this)
            }.bind(this),30) 
        },
        fn8: () => {
            setTimeout( () => {
                console.log(this)
            },40) 
        }
    }

    app.fn1()
    app.fn2()()
    app.fn3()
    app.fn4().fn()
    app.fn5()
    app.fn6()
    app.fn7()
    app.fn8()
    ```
    <------------------ 分割线 ------------------>

    ```js
    app.fn1() // app                      +
    app.fn2()() // app                    x window
    app.fn3() // app                      x window
    app.fn4().fn() // undefined           x app
    app.fn5() // window                   +
    app.fn6() // window                   x app
    app.fn7() // app                      +
    app.fn8() // window                   +
    ```

    答案：
    ```js
    app.fn1()//app
    app.fn2()()//window(undefined)
    app.fn3()//window(undefined)
    app.fn4().fn()//app
    app.fn5()//window(undefined)
    app.fn6()//app
    app.fn7()//app
    app.fn8()//window(undefined)
    ```

    链接：https://www.jianshu.com/p/80b273701ab2

    

    - [彻底搞懂JavaScript中的this指向问题 【知乎】](https://zhuanlan.zhihu.com/p/42145138)
    - [彻底理解js中this的指向，不必硬背](https://www.cnblogs.com/pssp/p/5216085.html)
        - > 谁调用的就指向谁
    - [简单快速理解js中的this、call和apply 【掘金】](https://juejin.im/post/6844903576532172813)



- ## [JavaScript 中 call()、apply()、bind() 的用法](https://www.runoob.com/w3cnote/js-call-apply-bind.html)
    - 其实是一个很简单的东西，认真看十分钟就从一脸懵B 到完全 理解！
    - 先看明白下面：
    - **例1：**
        ```js
        var name = '小王', age = 17
        var obj = {
            name: '小张',
            objAge: this.age,
            myFun: function () {
                console.log( this.name + '年龄' + this.age )
            }
        }
        ```
        ```js
        obj.objAge;  // 17
        obj.myFun()  // 小张年龄 undefined
        ```
    - **例2：**
        ```js
        var fav = '盲僧'
        function shows() {
            console.log(this.fav)
        }
        ```
        ```js
        shows()  // 盲僧　
        ```
    - 比较一下 上面 例1 例2 这两者 this 的差别，第一个打印里面的 this 指向 obj，第二个全局声明的 shows() 函数 this 是 window ；
    - ###  **1.call()、apply()、bind() 都是用来重定义 this 这个对象的！**
        ```js
        var name = '小王', age = 17;
        var obj = {
            name: '小张',
            objAge: this.age,
            myFun: function () {
                console.log( this.name + '年龄' + this.age )
            }
        }
        var db = {
            name: '德玛',
            age: 99
        }
        ```
        ```js
        obj.myFun.call(db)；　　　　// 德玛年龄 99
        obj.myFun.apply(db);　　　 // 德玛年龄 99
        obj.myFun.bind(db)();　　　// 德玛年龄 99
        ```
        以上除了 bind 方法后面多了个 () 外 ，结果返回都一致！

        由此得出结论，bind 返回的是一个新的函数，你必须调用它才会被执行。

        > call()、apply()、bind() 都是用来重定义 this 这个对象的！ <br>
        > call()、apply()、bind() 都是 **引用了原函数的结构 (处理逻辑)，但是却使用了新的this** <br>
        > call()、apply()、bind() 都是 **引用了原函数的结构 (处理逻辑)，但是this却指向了传入的对象**
        - 用上面 第3句话，一句话记住 `call()、apply()、bind()` 的用法

        <br>
        <br>

        - 最后再看 [官方定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function)
            - `Function.prototype.call()`
            - 在一个对象的上下文中应用另一个对象的方法；
        - 如何理解？举个例子
            - `obj.myFun.call(db)`
            - 在 db 对象的上下文中，应用 `obj.myFun` 这个方法
    - **2.对比call 、bind 、 apply 传参情况下**
        ```js
        var name = '小王', age = 17;
        var obj = {
            name: '小张',
            objAge: this.age,
            myFun: function (fm, t) {
                console.log( this.name + '年龄' + this.age, ' 来自 ' + fm + '去往' + t )
            }
        }
        var db = {
            name: '德玛',
            age: 99
        }
        ```
        ```js
        obj.myFun.call(db,'成都','上海')；　　　　 // 德玛 年龄 99  来自 成都去往上海
        obj.myFun.apply(db,['成都','上海']);      // 德玛 年龄 99  来自 成都去往上海  
        obj.myFun.bind(db,'成都','上海')();       // 德玛 年龄 99  来自 成都去往上海
        obj.myFun.bind(db,['成都','上海'])();　　 // 德玛 年龄 99  来自 成都, 上海去往 undefined
        ```
        微妙的差距！

        从上面四个结果不难看出:

        call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象，第二个参数差别就来了：

        call 的参数是直接放进去的，第二第三第 n 个参数全都用逗号分隔，直接放到后面 `obj.myFun.call(db,'成都', ... ,'string' )`。

        apply 的所有参数都必须放在一个数组里面传进去 `obj.myFun.apply(db,['成都', ..., 'string' ])`。

        bind 除了返回是函数以外，它 的参数和 call 一样。

        当然，三者的参数不限定是 string 类型，允许是各种类型，包括函数 、 object 等等！


# 第05章 JS基础-异步【三座大山之三，必考！！！】
## 5-1 同步和异步的区别
## 5-2 应用场景
## 5-3 promise
## 5-4 问题解答和总结
## 5-5 JS基本知识-总结


# 第05章 JS基础-异步【三座大山之三，必考！！！】
## 5-1 同步和异步的区别
## 5-2 应用场景
## 5-3 promise
## 5-4 问题解答和总结
## 5-5 JS基本知识-总结
----

# 异步编程
- 异步编程前言，为什么会出现异步编程？：[《阮一峰异步编程》](http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html)
    - "异步模式"编程的4种实现方法
        - 一、回调函数
        - 二、事件监听
        - 三、发布/订阅
        - 四、Promises对象
    - [JS 异步解决方案的发展历程以及优缺点](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/11)


----
