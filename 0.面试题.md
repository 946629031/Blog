# 快速搞定前端初级 JavaScript 面试
- 慕课网 ( 双越 老师 )

<br><br>

# 高效学习三步曲
    - 1.找准知识体系
    - 2.刻意练习
    - 3.及时反馈

- 知识体系：结构化的知识范围
- 涵盖所有知识点；结构化、有组织、易扩展

> 要进一线互联网公司，js基础知识 一定要 一定要 扎实

----

- [JavaScript基础面试题受益匪浅（转）](https://zhuanlan.zhihu.com/p/79547341)
- [JS基础知识（覆盖JS基础面试题）](https://juejin.im/post/6844903625618096141)

----
目录
- [第01章 课程介绍【说说面试的那些事儿】](#第01章-课程介绍【说说面试的那些事儿】)
    - [1 课程介绍](#1-课程介绍)
    - [1-3 几个面试题](#1-3-几个面试题)
    - [1-5 知识体系](#1-5-知识体系)
    - [知识体系 细分](#-知识体系-细分)
- [第02章 JS基础-变量类型和计算【不会变量，别说你会JS】](#第02章-JS基础-变量类型和计算【不会变量，别说你会JS】)
    - [2-1 值类型 和 引用类型](#2-1-值类型-和-引用类型)
    - [2-2 typeof 和 深拷贝](#2-2-typeof-和-深拷贝)
        - [typeof 运算符](#typeof-运算符)
        - [null 是对象吗？](#null-是对象吗？)
        - [判断数据类型](#判断数据类型)
        - [NaN === NaN false?](#NaN-===-NaN-false?)
        - [深拷贝](#深拷贝)
    - [2-3 变量计算 - 隐式类型转换](#2-3-变量计算---隐式类型转换)
        - [字符串拼接](#字符串拼接)
        - [== 运算符](#==-运算符)
        - [truly 变量 和 falsely 变量](#truly-变量-和-falsely-变量)
        - [if 语句](#if-语句)
        - [逻辑运算](#逻辑运算)
- [第03章 JS基础-原型和原型链【三座大山之一，必考！！！】](#第03章-JS基础-原型和原型链【三座大山之一，必考！！！】)
    - [3-1 题目和知识点](#3-1-题目和知识点)
    - [3-2 class和继承](#3-2-class和继承)
        - [Class](#Class)
        - [继承](#继承)
    - [3-3 原型](#3-3-原型)
        - [原型指向](#原型指向)
    - [3-4 原型链 和 instanceof](#3-4-原型链-和-instanceof)
    - [3-5 问题解答和总](#3-5-问题解答和总)
- [第04章 JS基础-作用域和闭包【三座大山之二，不会闭包，基本不会通过】](#第04章-JS基础-作用域和闭包【三座大山之二，不会闭包，基本不会通过】)
    - [4-1 作用域和自由变量](#4-1-作用域和自由变量)
        - [创建 10 个 a 标签，点击的时候 弹出对应的序号](#创建-10-个-a-标签，点击的时候-弹出对应的序号)
        - [作用域](#作用域)
        - [自由变量](#自由变量)
    - [4-2 闭包 closure](#4-2-闭包-closure)
        - [什么是闭包？](#什么是闭包？)
        - [闭包 的 主要应用](#闭包-的-主要应用)
            - [1.隐藏数据](#1.隐藏数据)
            - [2.模块模式](#2.模块模式)
            - [3.for循环](#3.for循环)
            - [4.函数柯里化](#4.函数柯里化)
    - [4-3 this](#4-3-this)
    - [4-4 问题解答](#4-4-问题解答)
        - [手写 bind 函数](#手写-bind-函数)
        - [JavaScript 中 call()、apply()、bind() 的用法](#JavaScript-中-call()、apply()、bind()-的用法)

- [第05章 JS基础-异步【三座大山之三，必考！！！】](#第05章-JS基础-异步【三座大山之三，必考！！！】)
    - [5-1 同步和异步的区别](#5-1-同步和异步的区别)
    - [5-2 应用场景](#5-2-应用场景)
    - [5-3 promise](#5-3-promise)
    - [5-4 问题解答和总结](#5-4-问题解答和总结)
    - [5-5 JS基本知识-总结](#5-5-JS基本知识-总结)
- [第06章 JS-Web-API-DOM【学会DOM，才能具备网页开发的基础】](#第06章-JS-Web-API-DOM【学会DOM，才能具备网页开发的基础】)
    - [6-1 从JS基础到JS-Web-API](#6-1-从JS基础到JS-Web-API)
    - [6-2 DOM的本质](#6-2-DOM的本质)
        - [HTML 是什么？](#HTML-是什么？)
        - [HTML 和 DOM 的区别](#HTML-和-DOM-的区别)
    - [6-3 DOM节点操作](#6-3-DOM节点操作)
        - [获取 DOM 节点](#获取-DOM-节点)
        - [attribute](#attribute)
        - [property](#property)
    - [6-4 DOM结构操作](#6-4-DOM结构操作)
        - [新增/插入节点](#新增/插入节点)
        - [获取子元素列表，获取父元素](#获取子元素列表，获取父元素)
        - [删除子元素](#删除子元素)
    - [6-5 DOM性能](#6-5-DOM性能)
        - [对 DOM 查询做缓存](#对-DOM-查询做缓存)
        - [将频繁 DOM操作 改为一次性操作](#将频繁-DOM操作-改为一次性操作)
    - [6-6 问题解答和小结](#6-6-问题解答和小结)

- [第07章 JS-Web-API-BOM【内容虽然不多，但是你不能不会】](#第07章-JS-Web-API-BOM【内容虽然不多，但是你不能不会】)
    - [navigator](#navigator)
    - [screen](#screen)
    - [location](#location)
    - [history](#history)
- [第08章 JS-Web-API-事件【事件不会，基本等于半残废，必考！必考！】](#第08章-JS-Web-API-事件【事件不会，基本等于半残废，必考！必考！】)
    - [通用事件监听函数 优化版](#通用事件监听函数-优化版)
    - [8-1 事件绑定和事件冒泡]()
        - [事件绑定](#事件绑定)
        - [事件冒泡](#事件冒泡)
    - [8-2 事件代理](#8-2-事件代理)
        - [事件代理 的优点](#事件代理-的优点)
    - [8-3 问题答疑和小结](#8-3-问题答疑和小结)
- [第09章 JS-Web-API-Ajax【每个工程师必须熟练掌握的技能】](#第09章-JS-Web-API-Ajax【每个工程师必须熟练掌握的技能】)
    - [9-1 XMLHttpRequest](#9-1-XMLHttpRequest)
        - [xhr.readyState](#xhrreadyState)
        - [xhr.status / HTTP状态码](#xhrstatus-/-HTTP状态码)
    - [9-2 同源策略和跨域](#9-2-同源策略和跨域)
    - [9-3 jsonp和cors](#9-3-jsonp和cors)
        - [JSONP 跨域](#JSONP-跨域)
        - [CORS](#CORS)
    - [9-4 问题解答](#9-4-问题解答)
        - [手写一个简易的 ajax](#手写一个简易的-ajax)
    - [9-6 ajax的常用插件](#9-6-ajax的常用插件)

- [第10章 JS-Web-API-存储【内容虽然不多，但不可不会】](#第10章-JS-Web-API-存储【内容虽然不多，但不可不会】)
    - [10-1 cookie](#10-1-cookie)
    - [10-2 html5存储](#10-2-html5存储)

- [第11章 开发环境【不会这些，你就会被认定是菜鸟小白，没做过项目】](#第11章-开发环境【不会这些，你就会被认定是菜鸟小白，没做过项目】)
    - [11-1 关于开发环境](#11-1-关于开发环境)
    - [11-2 git介绍](#11-2-git介绍)
    - [11-3 git命令介绍](#11-3-git命令介绍)
    - [11-4 git命令演示](#11-4-git命令演示)
    - [11-5 chrome调试工具](#11-5-chrome调试工具)
    - [11-6 抓包](#11-6-抓包)
    - [11-7 webpack-搭建环境](#11-7-webpack-搭建环境)
    - [11-8 webpack-babel](#11-8-webpack-babel)
    - [11-9 webpack-ES6-Module](#11-9-webpack-ES6-Module)
        - [1.单个导出](#1.单个导出)
        - [2.批量导出](#2.批量导出)
        - [3.默认导出`export default`](#3.默认导出`export-default`)
    - [11-10 webpack-配置生产环境](#11-10-webpack-配置生产环境)
    - [11-11 linux常用命令](#11-11-linux常用命令)
        -[常用命令](#常用命令)
        -[vim vi 命令](#vim-vi-命令)


- [第12章 运行环境【这些会了，你就可以飞了】](#第12章-运行环境【这些会了，你就可以飞了】)
    - [12-1 运行环境介绍](#12-1-运行环境介绍)
    - [12-2 页面加载和渲染过程](#12-2-页面加载和渲染过程)
    - [12-3 页面加载和渲染-示例](#12-3-页面加载和渲染-示例)
    - [12-4 页面加载和渲染-问题解答](#12-4-页面加载和渲染-问题解答)
    - [12-5 性能优化-原则和方向](#12-5-性能优化-原则和方向)
    - [12-6 性能优化-示例](#12-6-性能优化-示例)
    - [12-7 性能优化-防抖debounce](#12-7-性能优化-防抖debounce)
    - [12-8 性能优化-节流throttle](#12-8-性能优化-节流throttle)
    - [12-9 安全-xss](#12-9-安全-xss)
    - [12-10 安全-xsrf](#12-10-安全-xsrf)
    - [12-11 运行环境总结](#12-11-运行环境总结)


- [第13章 课程总结【很有必要带你避免面试犯低级错误】](#第13章-课程总结【很有必要带你避免面试犯低级错误】)
    - [13-1 课程总结](#13-1-课程总结)
    - [13-2 面试技巧](#13-2-面试技巧)


- [第14章 真题模拟【我是来告诉你答案是什么】](#第14章-真题模拟【我是来告诉你答案是什么】)
    - [14-1 章节介绍](#14-1-章节介绍)


- []()
- []()
- []()
- []()
- []()
- []()

----
# 第01章 课程介绍【说说面试的那些事儿】
- ## 1 课程介绍
- 主要知识点
    - ES6 Class
    - Promise
    - 模块化
    - 手写代码题
    - webpack (最新版)
    - babel (最新版)
- 做什么？-- 讲解前端基础面试题
- 哪些部分？-- 基础知识，JS Web Api ，开发环境，运行环境
- 技术？-- 原型，作用域，异步，Ajax，事件，Webpack 等

- 基础知识
    - 原型，原型链
    - 作用域，闭包
    - 异步，单线程
- API
    - DOM，BOM
    - Ajax，跨域
    - 事件，存储
- 开发环境
    - 版本管理
    - 调试，抓包
    - 打包构建
- 运行环境
    - 页面渲染
    - 性能优化
    - Web安全

- ## 1-3 几个面试题
    ```
    1.typeof 能判断哪些类型？

    2.何时使用 === ，何时使用 ==

    3.window.onload 和 DOMContentLoaded 的区别？

    4.JS 创建10个 <a> 标签，点击的时候弹出对应的序号

    5.手写节流 throttle、防抖 debounce

    6.Promise 解决了什么问题？
    ```
    - 问题：
        - 拿到一个面试题，你第一时间 看到的是什么？
        - 如何看待网上搜出来的 永远做不完的题海？
        - 如何对待接下来遇到的面试题？
    - 答：
        - 考点
        - 不变应万变 （题可变，考点不变）
        - 题目到知识点，再到题目

    ```
    1.typeof 能判断哪些类型？
        - 考点：js变量类型
            - 基本类型 和 引用类型的区别
            - 深拷贝，浅拷贝
            - 怎么判断 一个东西 是不是对象

    2.何时使用 === ，何时使用 ==
        - 考点：隐式类型转换

    3.window.onload 和 DOMContentLoaded 的区别？
        - 考点：页面加载过程
            - 为啥 css 要放在 head 里，为啥 js 要放在 最底下

    4.JS 创建10个 <a> 标签，点击的时候弹出对应的序号
        - 考点：作用域
            - this 指向
            - 闭包

    5.手写节流 throttle、防抖 debounce
        - 考点：性能、体验优化

    6.Promise 解决了什么问题？
        - 考点：JS异步
            - 异步 和 同步 有什么区别
            - 为什么有异步？
            - 异步的应用场景是什么？它在什么地方用？
            - 定时器 该如何使用？
    ```
    - 答：
        - 1.typeof 能判断哪些类型？
            - string number booleam undefined null symbol
            - object ( Array[] , Object{} )
            - function
        - 2.何时使用 === ，何时使用 ==
            - 允许 隐式类型转换 的情况下，可以用 ==
            - 其他情况下 用 ===

## 1-5 知识体系

## 前端知识体系怎么梳理？
- ### **W3C 标准**
    - Html、Css、DOM操作、BOM操作、Ajax、事件绑定
- ### **ECMA 262 标准**
    - 规定 JS 语法标准
        - 变量定义、if else、function定义、原型方式、闭包方式、Promise
- ### 开发环境
    - 代码版本管理、调试、打包上线
- ### 运行环境
    - 加载、性能优化、安全

<br><br>

## 知识体系
- ### 基础语法
    - 变量定义、变量类型判断、逻辑运算、函数定义、原型、闭包、Promise、Class...
- ### JS-Web-API
    - 网页请求、点击事件...
    - 获取网页元素、获取浏览器URL、BOM操作、DOM操作...
- ### 开发环境
    - 代码版本管理、调试、打包上线、代码的架构设计方式
- ### 运行环境
    - 加载、性能优化、安全

<br><br>

## 知识体系 细分
- ### ① JS基础知识
    - 变量类型和计算
        - 值类型 和 引用类型
        - 类型判断
        - 逻辑运算
    - 原型和原型链
        - Class
        - 继承
        - 原型
        - 原型链
        - instanceof
    - 作用域和闭包
        - 作用域
        - 自由变量
        - 闭包
        - this
    - 异步
        - 单线程
        - callback
        - 应用场景
        - Promise
    - 模块化
        - ES6 Module
- ### ② JS-Web-API
    - DOM
        - 树形结构
        - 节点操作
        - 属性
        - 树结构操作
        - 性能
    - BOM
        - navigator
        - screen
        - location
        - history
    - 事件
        - 绑定
        - 冒泡
        - 代理
    - ajax
        - XMLHttpRequest
        - 状态码
        - 跨域
    - 存储
        - cookie
        - localStorage
        - sessionStorage
- ### ③ 开发环境
    - git
    - 调试
    - webpack 和 babel
    - linux命令
- ### ④ 运行环境
    - 页面加载
        - 加载
        - 渲染
    - 性能优化
        - 加载资源优化
        - 渲染优化
    - 安全
        - xss
        - CSRF

<br>

- ### 特别提醒
    - 这仅仅是符合本课程目标和范围的知识体系
    - 并不是所有前端的知识体系,如没有vue React nodejs等
    - 知识体系也是有层次的,要循序渐进

----



# 第02章 JS基础-变量类型和计算【不会变量，别说你会JS】

## 2-1 值类型 和 引用类型
题目 -> 知识点 -> 解答
- 当你看到 考点时，如果你就能想得到 应该出哪些题 来考察候选人，这才是 见基本功，见能力 的事情

```
- 题目
    - typeof 能判断哪些类型
    - 何时使用 === ，何时使用 ==
    - 值类型 和 引用类型 的区别
    - 手写深拷贝 （涉及 递归）
```
- 知识点
    - 值类型 vs 引用类型
    - typeof 运算符
    - 深拷贝
        - 为什么 js 默认只支持 浅拷贝，不支持 深拷贝？

- 值类型
    ```js
    let a = 20;
    let b = a;
    b = 30;
    console.log(a); // 20
    ```
    ![](./img/0.interview-question/2.jpg)
- 引用类型
    ```js
    let m = { a: 10, b: 20 };
    let n = m;
    n.a = 15;
    console.log(m.a) // 15
    ```
    ![](./img/0.interview-question/3.jpg)
- 值类型 和 引用类型 的区别
    - 值类型 直接保存在 "栈区 Stack"，而 引用类型 是在栈里保存 堆地址，堆地址指向 "堆Heap" 内存 保存的内容。
    - 值类型 都是各自独立保存的，不会互相干扰。引用类型 有可能会互相干扰

- 为什么？
    - 为什么 值类型 可以直接把 数据保存了
    - 而 引用类型 却要先保存 堆地址，然后再用 堆地址 指向 堆内存中的数据？
    - 为什么 引用类型 不能直接保存数据？

- 因为
    - **值类型** 占用空间比较小，可以直接赋值，而且 赋值操作的时候 也不会对性能 造成什么影响
    - **引用类型** 占用空间 可以很大很大，在复制 的时候 可能由于 数据内容太大 而影响性能
    - 他是因为基于 内存的空间 和 CPU计算的耗时 来做的这种区分

- 常见值类型
    ```js
    const a // 报错 Uncaught SyntaxError: Missing initializer in const declaration

    let a // undefined
    const s = 'abc'
    const n = 100
    const b = true
    const s = Symbol('s')
    ```
    - 注意：如果 使用 `const` 时，没有赋值 会直接报错

- 常见 引用类型
    ```js
    const obj = { x:100 }
    const arr = ['a', 'b', 123]

    // 特殊引用类型, 但不用于存储数据，所以没有 "拷贝，复制函数" 这一说
    function fn () {}
    ```

## 2-2 typeof 和 深拷贝
- ## typeof 运算符
    - typeof 能区分的类型
        - 能区分所有值类型
        - 识别函数
        - 判断是否是引用类型 （不可在细分）
    ```js
    // typeof 能判断所有值类型, 除了 null
    let a;                      typeof a   // 'undefined'
    const str = 'abc';          typeof str // 'string'
    const n = 100;              typeof n   // 'number'
    const b = true;             typeof b   // 'boolean'
    const s = Symbol('s');      typeof s   // 'symbol'
    ```
    ```js
    // typeof 能判断函数
    typeof console.log  // 'function'
    typeof function(){} // 'function'

    // typeof 能判断 引用类型 （不可在细分）
    typeof null        // 'object'
    typeof ['a', 'b']  // 'object'
    typeof { x: 100 }  // 'object'
    ```

- ## null 是对象吗？
    - 先来看现象
    ```js
    typeof null // object
    ```
    - what ?  `null` 是 对象 ？？？ `null` 不是基本类型吗？

    <br>

    - [值 null 特指对象的值未设置。它是 JavaScript 基本类型 之一](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null)
    - [`typeof null` 返回 `object` **似乎是历史遗留的bug**](https://github.com/YvetteLau/Step-By-Step/issues/5)
    - [Null is not an object in JavaScript! typeof null === 'object' but that's a bug! ](https://stackoverflow.com/questions/801032/why-is-null-an-object-and-whats-the-difference-between-null-and-undefined)
        - [Here's a link Watch all the videos and enjoy :)](https://www.youtube.com/watch?v=JxAXlJEmNMg)
    ```js
    Object.prototype.toString.call(null)  // "[object Null]"
    ```

- ## [判断数据类型](https://www.jianshu.com/p/585926ae62cc)
    - `typeof null || Object.prototype.toString.call(null) `
    - `Object.prototype.toString.call()` 永远能够正确判断 正确的数据类型
    - **typeof**
        - `typeof` 判断数据类型，只能区分基本类型，即：`number`、`string`、`undefined`、`boolean`、`symbol`、`object`。
        - 对于 `null`、`array`、`function`、`object`来说，使用 `typeof` 都会统一返回 `object` 字符串。
    - `Object.prototype.toString.call()`
        - 要想区分对象、数组、函数、单纯使用typeof是不行的。在JS中，可以通过 `Object.prototype.toString` 方法
        - 可以区分
            - 基本类型 `null`、`string`、`boolean`、`number`、`undefined`、`null`
            - 复杂类型 `array`、`object`、`function`
            - 还可以区分 `date`、`math`、`RegExp`、`JSON`
        ```js
        Object.prototype.toString.call(null); // "[object Null]"
        Object.prototype.toString.call(undefined); // "[object Undefined]"
        Object.prototype.toString.call(“abc”);// "[object String]"
        Object.prototype.toString.call(123);// "[object Number]"
        Object.prototype.toString.call(true);// "[object Boolean]"
        ```
        ```js
        // **函数类型**
        Function fn(){
            console.log(“test”);
        }
        Object.prototype.toString.call(fn); // "[object Function]"
        ```
        ```js
        // **正则表达式**
        var reg = /[hbc]at/gi;
        Object.prototype.toString.call(reg); // "[object RegExp]"
        ```
        ```js
        // **日期类型**
        Object.prototype.toString.call(new Date()) // "[object Date]"
        ```
        ```js
        Object.prototype.toString.call(Math) // "[object Math]"

        Object.prototype.toString.call(JSON) // "[object JSON]"

        Object.prototype.toString.call([1]) // "[object Array]"
        Object.prototype.toString.call({})  // "[object Object]"
        ```
        ```js
        // **自定义类型**
        function Person (name, age) {
            this.name = name
            this.age = age
        }
        var person = new Person('Rose', 18)
        Object.prototype.toString.call(person) // "[object Object]"
        ```
        - 很明显这种方法不能准确判断 `person` 是 `Person` 类的实例，而只能用 `instanceof` 操作符来进行判断，如下所示：
        ```js
        console.log(person instanceof Person); // true
        ```
- ## NaN === NaN false?
    先来看一个现象
    ```js
    NaN == NaN  //false
    NaN === NaN // false
    ```
    - [Why is NaN === NaN false? ](https://stackoverflow.com/questions/19955898/why-is-nan-nan-false)
        - Because Not a Number is not a number, and is not equal to anything, including Not a Number

    <br>
    
    ```js
    typeof NaN // "number"

    Object.prototype.toString.call(NaN) // "[object Number]"
    ```
    - 虽然 用上面的类型判断，都返回 `number` ，但实际上 他不是一个 `number`，
    - 而且 `NaN` 不等于任何东西

- ## 深拷贝
    - 手写 深拷贝 的 考点：
        - 基本类型 和 引用类型
        - 递归
        - 要求手写，就是做考察 逻辑是否清晰
    ```js
    function deepClone ( obj={} ) {
        if ( typeof obj !== 'object' || obj == null ) {
            // obj 是 null，或者不是对象和数组，直接返回
            return obj
        }

        // 初始化返回结果
        // 如果 obj 是数组，就用 [] 包裹；如果 obj 是对象，就用 {} 包裹
        let result
        if (obj instanceof Array) {
            result = []
        } else {
            result = {}
        }

        for (let key in obj) {
            // 保证 key 不是原型链的属性
            if (obj.hasOwnProperty(key)) {
                // 递归调用！！！
                result[key] = deepClone(obj[key])
            }
        }

        // 返回结果
        return result
    }
    ```
    - 深拷贝思路：
        - 注意判断值的类型。如果是基本类型 就直接返回；如果是 引用类型 就递归
        - 注意判断是 数组 还是 对象
        - 递归

    ```js
    // 测试用例
    const obj1 = {
        age: 20,
        name: 'xxx',
        address: {
            city: 'beijing',
            a: {
                x: {
                    y: 'yName',
                    arr: [
                        {x: 1},
                        [1, 3, 6]
                    ],
                    reg: /\d/gi,
                    fn2: function(){ console.log('this is function2') },
                }
            }
        },
        fn: function(){ console.log('this is function') },
        arr: ['a', 'b', 'c']
    }

    const obj2 = deepClone(obj1)
    obj2.address.city = 'New York'
    console.log(obj2.address.city)
    console.log(obj1)
    console.log(obj2)
    console.log(obj2.fn(), obj2.address.a.x.fn2())
    
    ```

## 2-3 变量计算 - 隐式类型转换
```
- 有3种情况 最容易发生 隐式类型转换

    - 字符串拼接
    - ==
    - if 语句和逻辑运算
```

- ### **字符串拼接**
    - 字符串拼接，是最容易发生 隐式类型转换 的场景之一
    - > `'字符串'` 和任何东西 相加 `+`，就有可能发生 **`字符串拼接`**
    ```js
    // 基本类型
    const a = 100 + 10      // 110
    const b = '100' +　'10' // "10010"
    const c = 100 + '10'    // '10010'
    const d = true + '10'   // 'true10'
    const e = undefined + '10' // "undefined10"
    const f = null + '10'   //"null10"

    // 复杂类型
    const g = [1] + '12'    // "112"
    const h = {a:2} + '12'  // 12
    function fn(){} + '12'  // 12


    Symbol('1') + '12'   // Uncaught TypeError: Cannot convert a Symbol value to a string
    ```
    > 总结： <br>
    >   - `'字符串'` 和任何东西 相加 `+`，都会优先发生 **`字符串拼接`** <br>
    >   - 如果实在没办法 发生 `字符串拼接`，才会 隐式转换成 **`数学运算`** <br>
    >   - `Symbol()` 和任何东西 相加 `+`，都会报错
    ```js
    // 多类型 混合运算

    {a:2} + '12' + '1'　+ 1 + null + true + undefined +　[9]
    // "1211nulltrueundefined9"

    [9] + {a:2} + '12' + '1'　+ 1 + null + true + undefined
    // "9[object Object]1211nulltrueundefined"

    {a:2} + '12' + '1'　+ 1 + null + true + undefined + function fn(){}
    // "[object Object]1211nulltrueundefinedfunction fn(){}"

    {a:2} + '12' + '1'　+ 1 + null + true + undefined + function fn(){} + Symbol(1)
    // Uncaught TypeError: Cannot convert a Symbol value to a string
    ```
    - **显示转换**
        - 某些情况下，如果不能确定 传入的数据类型，可以先 **显示转换** 然后再进行运算，如
        ```js
        100 + parseInt('10') // 100
        ```

- ### **`==` 运算符**
    - **`==` 运算符**, 是最容易发生 隐式类型转换 的场景之一
    > **`==` 运算符**, 会优先 **尽量尝试** 让他们转换类型之后，再判断 他们是否相等
    ```js
    100 == '100' // true
    0 == ''      // true
    0 == false   // true
    false == ''  // true
    null == undefined // true
    ```
    - 如果不希望 发生 **`隐式类型转换`**
        - 那么除了 `== null` 之外，其他情况 都一律用 `===`, 例如：
        ```js
        const obj = { x: 100 }
        if ( obj.a == null ) { }

        // 相当于：
        if ( obj.a === null || obj.a === undefined ) { }
        ```
        > `( obj.a == null ) ` 等价于 ` ( obj.a === null || obj.a === undefined )` <br>
        > 在很多 知名项目中 都是这么用的，如 jQuery, EsLint...

- ### **`truly 变量`** 和 **`falsely 变量`**
    - **`truly 变量`**: `!!a === true` 的变量
    - **`falsely 变量`**: `!!a === false` 的变量
    > 经过两次 **`!` 非运算**，如果等于 `true` 就是 **`truly 变量`**，如果等于 `false` 就是 **`falsely 变量`**
    ```js
    const n = 100
    !n  // false
    !!n // true
    // 所以 100 属于 truly变量

    const m = 0
    !m  // true
    !!m // false
    // 所以 0 属于 falsely变量
    ```
    - 以下 **`6种情况`** 是 falsely 变量。除此之外都是 truly 变量
        > 除了 **`5种基本类型，加上 NaN`** 双取反 为 falsely 变量 之外，其他都是 truly 变量
        ```js
        !!0 === false
        !!'' === false
        !!false == false
        !!undefined === false
        !!null === false
        !!NaN === false
        ```
- ### **`if` 语句**
    > 实际上 **`if` 语句** 判断的就是 **`truly 变量`** 和 **`falsely 变量`**，而不是判断 true or false
    ```js
    // truly 变量
    const a = true
    if (a) {}

    const b = 100
    if (b) {}
    ```
    ```js
    // falsely 变量
    const c = ''
    if (c) {}

    const d = null
    if (d) {}

    let e
    if (e) {}
    ```

- ### **逻辑运算**
    - [现代 JavaScript 教程 — 逻辑运算符](https://juejin.im/post/6844903991139123208)
    - 逻辑运算符
        - JavaScript 里有三个逻辑运算符：`||`（或），`&&`（与），`!`（非）
        > `||` 或运算 寻找第一个真值<br>
        > `&&` 与操作 寻找第一个假值<br>
        > `!` &nbsp; 非操作 取反
        
        > `||` 或运算 寻找第一个真值，或返回最后一个 falsely 变量 <br>
        > `&&` 与操作 寻找第一个假值，或返回最后一个 truly 变量<br>
        > `!` &nbsp; 非操作 取反

        > `||` 或运算 返回第一个真值，或返回最后一个假值 <br>
        > `&&` 与操作 返回第一个假值，或返回最后一个真值<br>
        > `!` &nbsp; 非操作 取反
    ```js
    10 && 0     // 0
    '' || 'abc' // 'abc'
    !window.abc // true
    ```


# 第03章 JS基础-原型和原型链【三座大山之一，必考！！！】
## 3-1 题目和知识点
- 原型和原型链
    - 原型和原型链 是js比较重要的 知识点，必考！
    - 如果面试中，不考原型和原型链，要么面试官是煞笔，要么这个岗位非常不重要
- 为什么 原型和原型链 重要？
    - 因为 js本身 就是 **`基于原型继承`** 的语言
    - 在 ES6 之前，**`继承`** 只能通过 **`原型继承`**。不像别的语言，如 JAVA 能通过 Class 来继承
    - ES6 时，js 才有了 Class 的方法来继承
        - 但是经过破解发现，ES6 的 Class 只是形式上实现了 Class 的写法而已，本质上的继承 还是 原型继承
```
- 题目
    - 1.如何准确判断一个变量是不是 数组？
        - x instanceof Array
        - 那么问题来了：这个 instanceof 到底是怎么判断出来 它到底是不是数组 ？ 这是一个值得思考的问题

    - 2.手写一个简易的 jQuery，考虑插件和扩展性
        - jQuery 慢慢变得不常用了。但是 学习 jQuery 的设计方式，学习 js基础知识，可以类比 我们本节要学习的原型 这部分内容，让我们更容易理解 原型

    - 3.Class 的原型本质，怎么理解？
        - 这个问题 比较偏概念
        - 但是 越是偏概念的问题，就越是能 考察你对基础知识的理解能力，你能不能 通过自己的语言 把这些知识表述出来 (或 通过画图的方式 讲事情讲解清楚)。
```

## 3-2 class和继承
- ## Class
    - ### 什么是 Class
        - Class 是面向对象的一个语法实现
    - ### Class 内有什么
        - constructor 构建函数
        - 属性
        - 方法

    ```js
    class Student {
        constructor (name, number) {
            // this 指向 你当前正在构建的实例
            this.name = name // 属性
            this.number = number
            this.gender = 'male'
        }
        learn () { // 方法
            console.log( `学生 ${this.name} is learning` )
        }
    }

    // 通过类声明 对象/实例
    const xialuo = new Student('夏洛', 100)  // `new Student()` 时，就会走 `constructor()` 构建函数，来生成对象

    console.log(xialuo.name)
    console.log(xialuo.number)
    xialuo.learn()
    ```
    - `new Student()` 时，就会走 `constructor()` 构建函数，来生成对象

- ## 继承
    - ### 什么是继承？
        - 打个比方：
            - 现在已有 人、老师、学生 这3个分类 Class
            - 老师和学生 都是属于人 这个分类
            - 而人都有一个共性，比如 都有吃的方法，都有说话的方法
            - 现在我需要创建一个新的职业，如 司机。但是如果我重新开始写 吃 和 说话的方法 又太麻烦了，而且这些方法 人这个分类本来就有。那我现在 直接通过 人这个分类 直接继承过来，就好了
            - 这就是 继承
            - 然后把 司机 自己特有的属性和方法 再加到 司机这个 类Class 上就可以了
    - ### 继承里有什么？
        - extends
        - super
            - 通过 `super()` 执行父类的 `constructor()`
        - 扩展或重写方法
    ```js
    // 父类
    class People {
        constructor (name) {
            this.name = name
        }
        eat () {
            console.log(`${this.name} eat something`)
        }
    }

    // 子类
    class Student extends People {
        constructor (name, number) {            
            super(name) // 通过 `super()` 执行父类的 `constructor()`
            this.number = number
        }
        learn () {
            console.log(`学生 ${this.name} is learning`)
        }
    }

    // 子类
    class Teacher extends People {
        constructor (name, major) {
            super(name)
            this.major = major
        }
        teach () {
            console.log(`${this.name} 教授 ${this.major}`)
        }
    }

    // 实例
    const xialuo = new Student('夏洛', 100)
    console.log(xialuo.name)
    console.log(xialuo.number)
    xialuo.learn()
    xialuo.eat()

    const wanglaoshi = new Teacher('王老师', '语文')
    console.log(wanglaoshi.name)
    console.log(wanglaoshi.major)
    wanglaoshi.teach()
    wanglaoshi.eat()
    ```

## 3-3 原型
- ### 类型判断 - instanceof 
    - instanceof 可以判断 这个变量 是属于哪个 `Class` 或 `构造函数`
    ```js
    xialuo instanceof Student // true
    xialuo instanceof People  // true
    xialuo instanceof Object  // true

    [] instanceof Array  // true
    [] instanceof Object // true

    {} instanceof Object // true
    ```
- ### 原型
    ```js
    // js 里的 Class 实际上是函数，可见是语法糖
    typeof People  // 'function'
    typeof Student // 'function'
    ```
    > js 里的 Class继承 实际上是函数继承，不像 java 这种真正的 纯Class 的继承 <br>
    > 而是像 js里的这种 原型继承 <br>
    > 可见 js里的 Class 只是一种语法糖。写法是 Class 的写法，但实际上 是 js的原型继承

    ```js
    // 调用实例的方法 或 属性
    xialuo.number  // 100
    xialuo.name    // "夏洛"
    xialuo.learn() // 姓名 夏洛 学号 100
    ```
    - #### 下面来看几个现象
        ```js
        xialuo.__proto__

        -----

        ↓ People {constructor: ƒ, learn: ƒ}
          → constructor: class Student
          → learn: ƒ learn()
          → __proto__: Object
        ```
        ```js
        Student.prototype  // prototype 就是 原型

        -----

        ↓ People {constructor: ƒ, learn: ƒ}
          → constructor: class Student
          → learn: ƒ learn()
          → __proto__: Object
        ```
        ```js
        Student.prototype === xialuo.__proto__   // true
        ```
    - 到这里，我们初步总结一下
        ```js
        xialuo.__proto__   // 我们称之为  隐式原型
        Student.prototype  // prototype 就是 显示原型
        Student.prototype === xialuo.__proto__   // true  
        ```
        - `xialuo.__proto__`    我们称之为  **`隐式原型`**
        - `Student.prototype`   prototype 就是 **`显示原型`**
        - `Student.prototype === xialuo.__proto__   // true`  
            - 而且 显示原型 与 隐式原型 是完全相等的（引用的是同一个 堆内存 地址）
    - ### 原型指向
        ![](./img/0.interview-question/4.jpg)
        - 这里的原型指向，实际上就是 上面 `xialuo.__proto__` 和 `Student.prototype` 的代码版 的示意图
            - ① 第一个指向
                - ~~`Student` 这个 Class ，他的 `原型prototype` 指向 `对象Student.prototype`~~<br><br>
                - `Student` 这个 `对象/Class` 里面有一个 `prototype属性`，这个 `prototype属性` 指向 `对象Student.prototype`
                - 而 `Student.prototype` **这个对象** 里面有一个 `learn() 方法`
            - ② 第二个指向
                ```js
                const xialuo = new Student()
                ```
                - xialuo 被 new 出来后，就成为了一个 Student() 的实例了
                - 这个实例 他有自己的属性，如 `name: '夏洛'` , `number: 100`
                - 除此之外 还有一个 `__proto__隐式原型` **`属性`**，这个 属性也指向 `Student.prototype` **这个对象**

        ![](./img/0.interview-question/5.jpg)
        - 从上图我们可以看出 规律
            - 规律 ① 
                - 当你求 一个 `类/Class` 的 `原型prototype` 时，他会显示 当前类 的 `父类` （图中画红线部分）
                - 当 这个类是顶层的 `父类` 时，图中画红线的地方 `不在显示 父类`
            - 规律 ②
                - 图中画蓝线的部分（`People` 右侧），显示的是 当前的对象 内容 （蓝框内 显示的是 `Student` 这个 类 的内容）
                - 当你展开后（下面蓝框里的内容），也就是 `Student` 这个 类 的内容

    - ### 原型关系
        - **每个 Class 都有显示原型 `prototype`**
        - **每个实例都有隐式原型 `__proto__`**
        - **实例的 `__proto__` 指向对应 class 的 `prototype`**
    - ### 基于原型的执行规则
        - **获取属性 `xialuo.name` 或 执行方法 `learn()` 时**
        - **先在自身属性 和 方法 寻找**
        - **如果找不到则 自动去 `__proto__` 中查找** <br><br><br>

        - 举个例子

            ![](./img/0.interview-question/6.jpg)
            - 当我求 `xialuo.name` 或 `xialuo.learn()` 时，他会 先在实例本身 去寻找
            - `xialuo.name` 找到了，返回结果 `夏洛`
            - `xialuo.learn()` 在实例本身寻找后，发现实例本身 并没有这个 属性 或 方法
            - 于是 它会自动去 `__proto__` 中查找，发现 `xialuo.__proto__.learn()` 这里是有这个方法的，于是执行并返回结果
            ```js
            xialuo.learn === xialuo.__proto__.learn // true
            ```
            > 这里发现，`xialuo.learn` 和 `xialuo.__proto__.learn` 这两个函数指向的 堆内存地址 是完全一样的



## 3-4 原型链 和 instanceof
- ## 原型链
    ```js
    Student.prototype.__proto__
    People.prototype
    People.prototype === Student.prototype.__proto__   // true
    ```
    ![](./img/0.interview-question/10.jpg)
    - 上面写的 这三个东西，其实 都是一个东西，都是引用同一个 堆内存地址

    <br><br>

    ![](./img/0.interview-question/7.jpg)

    - > 问题：当我们要求 `xialuo.eat()` 时，会发生什么？
    - 根据上一节，[基于原型的执行规则](#基于原型的执行规则) 我们知道：
        - 当我们求一个对象的 `属性` 或 `方法` ，如果他在 自己对象本身 没有找到该 `属性` 或 `方法`，他就会 顺着 `__proto__` 向上一级一级的寻找
        - > 这时候 就形成了一个 **`链`**，我们称之为 **`原型链`**。其中 `__proto__` 是 隐式原型，简称为 **`原型`**

    ![](./img/0.interview-question/8.jpg)
    ```js
    xialuo.name   // '夏洛'
    xialuo.hasOwnProperty('name')   // true

    xialuo.eat()  // 夏洛 eat something
    xialuo.hasOwnProperty('learn')  // false
    ```
    > 备注：`Object.hasOwnProperty()` 表示 对象自身属性中是否具有指定的属性 （ [MDN文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty) ）<br>
    > 自有属性 return true，继承来的 return false
    - 这里我们发现，虽然 `xialuo.eat()` 能够执行，但是 `eat()` 不是 `xialuo` 自己的属性

    <br><br>

- 那么问题又来了
    - 这个 `hasOwnProperty` 是从哪里来的呢？
    ```js
    xialuo.hasOwnProperty('hasOwnProperty')  // false
    ```
    - 由上可知 `xialuo` 的这个 `hasOwnProperty` 也是继承来的
    - 那么 它又是从哪里继承来的呢？

    <br><br>

![](./img/0.interview-question/9.jpg)
> 注意：顶层的 `Object.prototype.__proto__` 是指向 `null` 的
- 上图中，`Object` 和 `Object.prototype` 是 JS引擎 提供的，其中 `Object.prototype` 有许多已经定义好了的方法
    ![](./img/0.interview-question/11.jpg)
    - 其中 就包括了 `Object.prototype.hasOwnProperty()` 这方法
    - 所以 `xialuo.hasOwnProperty()` 是通过向上 一层层继承来的 **`xialuo.__proto__.__proto__.__proto__.hasOwnProperty`**
    ![](./img/0.interview-question/12.jpg)
    ```js
    xialuo.__proto__.__proto__.__proto__.hasOwnProperty === Object.prototype.hasOwnProperty // true
    ```
    > 小插曲 [【stackoverflow】Why Object.prototype.hasOwnProperty is Not equal to the instance.__proto__.hasOwnProperty](https://stackoverflow.com/questions/63424742/why-object-prototype-hasownproperty-is-not-equal-to-the-instance-proto-hasow)
    
- ### 再看 instanceof
    ![](./img/0.interview-question/13.jpg)
    ```js
    xialuo instanceof Student // true
    xialuo instanceof People  // true
    xialuo instanceof Object  // true
    ```
    - 你 `xialuo` 的 `隐式原型/__proto__`，如果能够 顺着 `父类` 的 `显示原型/prototype` 一层一层往上爬
    - 如果能够 找到对应的 `对象/Class`，那么 `instanceof` 就返回 `true`，否则返回 `false`

- 题外话：
    - 问题1：
        ```js
        xialuo.__proto__.learn() // 学生 undefined is learning
        xialuo.__proto__.name    // undefined
        xialuo.__proto__.number  // undefined

        
        xialuo.learn() // 学生 夏洛 is learning
        xialuo.name    // 夏洛
        xialuo.number  // 100
        ```
        - 为啥 `xialuo.__proto__.name` 这种方法上 访问 就是 `undefined`
        - 而 `xialuo.name` 直接调用就可以访问得到？
        > 这是 this 指向问题，**谁调用指向谁** <br>
        > `xialuo.__proto__.name` this 指向 `__proto__` <br>
        > `xialuo.name` this 指向 `xialuo` 这个实例对象
    - 问题2：
        - 看上面的原型图，xialuo 实例本身 其实是没有 `learn()` 方法的
        - 它是 通过调用 `xialuo.__proto__.learn()` 这种方式去执行的
        - 但是这里有个问题，从上一个问题中，我们知道 `xialuo.__proto__.learn()` 这种方式是会返回 `学生 undefined is learning` 的。
        - 那么 矛盾来了：`xialuo.learn()` 到底是怎么返回 `学生 夏洛 is learning`，而不是 `学生 undefined is learning` 的呢？
        <br><br><br>
        - 其实是类似于下面这种机制 （但是 不确定内部是不是这样实现的）
        ```js
        xialuo.__proto__.learn.call(xialuo)  // 学生 夏洛 is learning
        ```



![](./img/0.interview-question/14.jpg)


<br><br><br>
## 3-5 问题解答和总

```
- 题目解答 （视频 3-5）
    - 1.如何准确判断一个变量是不是 数组？
        - x instanceof Array
        - 那么问题来了：这个 instanceof 到底是怎么判断出来 它到底是不是数组 ？ 这是一个值得思考的问题

    - 2.手写一个简易的 jQuery，考虑插件和扩展性
        - jQuery 慢慢变得不常用了。但是 学习 jQuery 的设计方式，学习 js基础知识，可以类比 我们本节要学习的原型 这部分内容，让我们更容易理解 原型

        - 答：用 Class 的知识

    - 3.Class 的原型本质，怎么理解？
        - 这个问题 比较偏概念
        - 但是 越是偏概念的问题，就越是能 考察你对基础知识的理解能力，你能不能 通过自己的语言 把这些知识表述出来 (或 通过画图的方式 讲事情讲解清楚)。

        - 答：原型 和 原型链 的图示 （这个图要闭着眼睛 都能画下来 才行）
        - 属性 和 方法的执行规则：通过隐式原型，一步一步往上去找那个方法
```
```js
class jQuery {
    constructor (selector) {
        const result = document.querySelectorAll(selector)
        const length = result.length
        for (let i = 0; i < length; i++) {
            this[i] = result[i]
        }
        this.length = length
        this.selector = selector
    }
    // 把这个对象 做成 类数组 的形式
    get (index) {
        return this[index]
    }

    each (fn) {
        for (let i = 0; i < this.length; i++) {
            const elem = this[i]
            fn(elem)
        }
    }
    on (type, fn) {
        return this.each(elem => {
            elem.addEventListener(type, fn, false)
        })
    }

    // 还可以扩展很多 DOM API
}



// 插件：如何添加 jQuery 插件？
jQuery.prototype.dialog = function (info) {
    alert(info)
}

// 扩展性/复写/造轮子
class myJQuery extends jQuery {
    constructor (selector) {
        super(selector)
    }
    // 扩展自己的方法
    addClass (addName) {
        for (let i = 0; i < this.length; i++) {
            let className = this[i].getAttribute('class')
            if (className != null) {
                className += ' '
                this[i].setAttribute('class', className + addName)
            } else {
                this[i].setAttribute('class', addName)
            }
        }
    }
    style (data) {}
}
```
```html
// 测试用例

<p>一段文字1</p>
<p>一段文字2</p>
<p>一段文字3</p>

<script>
const $p = new jQuery('p')
$p          // jQuery {0: p, 1: p, 2: p, length: 3, selector: "p"}
$p.get(1)   // <p>一段文字2</p>
$p.each( (elem) => {console.log(elem.nodeName)} )   // P
$p.on('click', () => { alert('clicked') })
</script>
```

### [Javascript中调用一个函数（对象），使用new或者直接调用有什么区别？【知乎】](https://www.zhihu.com/question/21220141/answer/17558024)

```js
function Man(age){
	this.sex="male";
	this.age=age;
}
m1=Man(20);
m2=new Man(21);
```

- m1就是函数Man()执行的返回值，也就是undefined. 在函数执行过程中，属性被加到全局作用域或者Man方法所属的对象上了。执行之后window.sex=="male"

- 而m2是Man的实例，Man {sex:"male",age:21}

```js
function Man(age) {
	var obj = new Object();
	obj.sex = "mail";
	obj.age = age;
	return obj;
}
m3=Man(22);
```
- 这个就不需要加new，m3是一个Object，不是Man的实例。

- native code中，加new就是返回这个构造函数的实例；不加作为函数就返回一个基本数据类型，或者会报错 “ DOM object constructor cannot be called as a function ”。

- Date()，不加new返回当前时间，是一个 **字符串**。加new的话，返回当前时间或者把参数格式化得到的时间，是一个 **Date对象**。

- String()，不加new将参数格式化为 **字符串**，加new则返回的是 **String对象**。它们的区别如下：

```js
var s1=new String(2);
//如果把s1 log到控制台中，输出 String{0:"2"}
var s2=String(2);
//如果把s2 log到控制台中，输出 '2'
console.log(typeof s1);
//"object"
console.log(typeof s2);
//"string"
s1.pro = 1;
console.log(s1.pro);
//1
s2.pro = 1;
console.log(s2.pro);
//undefined
```

- Number和String类似。
- Array，Object加不加new貌似是一样的？
- Image，XMLHttprequest等不能作为函数使用。


<br><br><br>


# 第04章 JS基础-作用域和闭包【三座大山之二，不会闭包，基本不会通过】
- ## 4-1 作用域和自由变量
    - 先看题
        ```
        this 的不同应用场景，如何取值？

        手写 bind 函数

        实际开发中闭包的应用场景，举例说明

        创建 10 个 a 标签，点击的时候 弹出对应的序号
        ```
        - 题目解析
            - bind 函数 是改变 this 指向 的方法之一
            - 考察点：1.看你会不会用bind 函数，2.看你手写的逻辑是否清晰
    - ### 创建 10 个 a 标签，点击的时候 弹出对应的序号
        ```js
        let i, a
        for (i = 0; i < 10; i++) {
            a = document.createElement('a')
            a.innerHTML = i+'<br>'
            a.addEventListener('click', function(e){
                e.preventDefault()
                alert(i)
            })
            document.body.appendChild(a)
        }
        ```
        - > 弹出来的 都是 10 ？？？
        - 问题分析：
            - 上面 i 和 a 都是全局变量
            - `for 循环` 本质上是创建了 多个 `{}` 块级代码
            - 如果 变量的作用域在 `{}` 块级代码内，那就能够达到预期的效果
        - 这个问题有两个解法
            ```js
            // 解法一：利用块级作用域，将 i 的作用域 放在 `{}` 块级代码内
            
            let a
            for ( let i=0; i<10; i++) {
                a = document.createElement('a')
                a.innerHTML = i + '<br>'
                a.addEventListener('click', function(e){
                    e.preventDefault()
                    alert(i)
                })
                document.body.appendChild(a)
            }
            ```
            ```js
            // 解法二：将变量放在 函数作用域内

            for(var i=0;i<10;i++){

                (function(i){
                    var a=document.createElement('a');

                    a.innerHTML=i+'<br>';

                    document.body.appendChild(a);

                    a.addEventListener('click',function(e){
                        e.preventDefault();  //取消默认事件，指a标签
                        alert(i);
                    });

                })(i);

            }
            ```
    - 前言：为什么要学？作用域和闭包
        - 面试过程中 如果 `作用域和闭包` 过不了的话，这个人我是不会要的
        - 如果 `作用域和闭包` 搞不清楚，在项目中 模块间相互调用，会产生 比较复杂的关系
        - 你如果这些关系屡不清，关系的作用域的问题，我是肯定不能要你的。要你来 写的代码 不知不觉 就会写出很多BUG 来
    - ### 作用域
        - 作用域 是什么？
            > **作用域就是一个变量的合法使用范围**

        ![](./img/0.interview-question/1.jpg)
        - #### 作用域 有三种
            ```
            全局作用域

            函数作用域

            块级作用域 (ES6新增)
            ```
            - 块级作用域
                ```js
                // ES6 块级作用域
                if (true) {
                    let x = 100
                }
                console.log(x) // 会报错
                ```
                `if , for , while ...` 后面的 `{}` 内都属于块级作用域
    - ### 自由变量
        - 自由变量 是什么？
            > 一个变量在当前作用域没有被定义，但被使用了
        - 向上级作用域，一层一层一次寻找，直到找到为止
        - 如果到全局作用域 都没找到，就会报错 xx is not defined
- ## 4-2 闭包 closure
    - 1.下面代码的输出是什么？
        ```js
        function create () {
            const a = 100
            return function () {
                console.log(a)
            }
        }

        const fn = create()
        const a = 200
        fn()
        ```
        ```js
        function print (fn) {
            const a = 200
            fn()
        }

        const a = 100
        function fn () {
            console.log(a);
        }

        print(fn)
        ```
        - 答案：都是 100

    - **闭包：闭包里 自由变量 的查找，是在函数定义的地方查找，而不是在函数执行的地方！！！**
    - ### 什么是闭包？
        - **闭包是作用域应用的特殊情况**，有两种表现：
            - > 函数作为返回值
            - > 函数作为参数被传递
    - [闭包 定义2](https://www.jianshu.com/p/80b273701ab2)：

        用高程里面的话说就是

        **有权访问另一个函数作用域中的变量的函数**

        其实是一个特别简单的东西，却被搞的好像很复杂。我们平时写得代码里经常写闭包。比如

        **我想把1存起来，下次调用的时候再打印出来**，由于作用域链的关系，fn()之后匿名函数还引用着a,所以a不会被清理掉，下次调用的时候就会打印出来了。
        ```js
        function fn(a){
            return  function(){
                console.log(a)
            }
        }
        fn(1)()//1
        ```
    - ### 闭包 的 主要应用
        - #### 1.隐藏数据
            - 闭包 隐藏数据，只提供 Api
                ```js
                // 如 做一个简单的 cache 工具

                function createCache () {
                    const data = {}  // 闭包中的数据，被隐藏，不被外部访问
                    return {
                        set: function (key, val) {
                            data[key] = val
                        },
                        get: function (key) {
                            return data[key]
                        }
                    }
                }

                const c = createCache()
                c.set('a', 100)
                console.log( c.get('a') )

                data.b = 200 // 无法访问 Uncaught ReferenceError: data is not defined
                // 如果不通过 c.set()  c.get()  就无法设置 和 获取数据
                ```
        - #### 2.模块模式
            ```js
            function fn () {
                const a =  1
                return {
                    dosomething: function () {
                        console.log(a)
                    }
                }
            }
            const foo = fn()
            foo.dosomething() //1
            ```
        - #### 3.for循环
          ```js
          for(var i=0; i<5; i++){
            (function(j){
              setTimeout(function(){
                console.log(j)
              }, j*1000)
            })(i)
          }
          ```
        - #### 4.函数柯里化
          ```js
          function curry(fn){
            const args = [...arguments].slice(1)
            return function(){
                const innerArgs =  [...arguments]
                const finnalArgs = args .concat(innerArgs)
                return fn.apply(null, finnalArgs)
            }
          }
          function add(n1,n2){
            return n1+n2
          }
          curry(add,5)(3)//8
          ```

- ## 4-3 this
    - > this 的取值 **是在函数执行时候确定的**，而不是定义时候 确定的

    - ## this总结（5点）
        - 1.普通函数调用，fn() 里面的 this 就是 window（非严格模式下）
            - fn() 是 strict mode，this 就是 undefined
        - 2.作为对象方法调用，`a.b.c.fn()` 里面的 this 就是 a.b.c
        - 3.在 Class 中调用，new F() 里面的 this 就是新生成的实例
        - 4.箭头函数 this 取值 `() => console.log(this)` ，永远是 它上级作用域的 this
        - 5.使用 `call(), apply(), bind()` 传入什么 this 就指向什么
        - 6.`setTimeout` 的函数内 this 是 window（非严格模式下）
            - 因为 setTimeout, setInterval 这种函数 都是先注册到 事件队列里，等到真正执行的时候 是由 window 来调用的，所以 setTimeout, setInterval 的 this 指向 window
        - 7.当然还有事件监听的时候，this是监听元素

    ```js
    function fn1 () {
      console.log(this)
    }
    fn1() // window

    fn1.call({ x: 100 }) // { x: 100 }

    const fn2 = fn1.bind({ x: 200 })
    fn2() // { x: 200 }
    ```
    ```js
    const zhangsan = {
      name: '张三',
      learn () {
        console.log(this) // this 即当前对象
      },
      wait () {
        setTimeout(function () {
          // this === window
          console.log(this)
        }, 0)
      }
    }
    ```  
    ```js
    const zhangsan = {
      name: '张三',
      learn () {
        console.log(this) // this 即当前对象
      },
      waitAgain () {
        setTimeout( () => {
          // this 即当前对象
          console.log(this)
        }, 0)
      }
    }
    ```
    ```js
    class People {
      constructor (name) {
        this.name = name
        this.age = 20
      }
      learn () {
        console.log(this)
      }
    }

    const zhangsan = new People('张三')
    zhangsan.learn() // zhangsan 对象
    ```
    
    - 下面看一道题（作全对，基本this过关）
    ```js
    var app = {
        fn1: function () {
            console.log(this)
        },
        fn2: function(){
            return function() {
                console.log(this)
            }
        },
        fn3: function() {
            function fn() {
                console.log(this)
            }
            return fn()
        },
        fn4: function() {
            return {
                fn: function () {
                    console.log(this)
                }
            }
        },
        fn5: function() {
            setTimeout(function () {
                console.log(this)
            },10) 
        },
        fn6: function() {
            setTimeout( () => {
                console.log(this)
            },20) 
        },
        fn7: function() {
            setTimeout(function () {
                console.log(this)
            }.bind(this),30) 
        },
        fn8: () => {
            setTimeout( () => {
                console.log(this)
            },40) 
        }
    }

    app.fn1()
    app.fn2()()
    app.fn3()
    app.fn4().fn()
    app.fn5()
    app.fn6()
    app.fn7()
    app.fn8()
    ```
    <------------------ 分割线 ------------------>

    ```js
    app.fn1() // app                      √
    app.fn2()() // app                    x window
    app.fn3() // app                      x window
    app.fn4().fn() // undefined           x app
    app.fn5() // window                   √
    app.fn6() // window                   x app
    app.fn7() // app                      √
    app.fn8() // window                   √
    ```

    答案：
    ```js
    app.fn1()//app
    app.fn2()()//window(undefined)
    app.fn3()//window(undefined)
    app.fn4().fn()//app
    app.fn5()//window(undefined)
    app.fn6()//app
    app.fn7()//app
    app.fn8()//window(undefined)
    ```

    链接：https://www.jianshu.com/p/80b273701ab2

<br><br><br>

- [彻底搞懂JavaScript中的this指向问题 【知乎】](https://zhuanlan.zhihu.com/p/42145138)
- [彻底理解js中this的指向，不必硬背](https://www.cnblogs.com/pssp/p/5216085.html)
    - > 谁调用的就指向谁
- [简单快速理解js中的this、call和apply 【掘金】](https://juejin.im/post/6844903576532172813)

<br><br><br>

- ## 4-4 问题解答
    - ### [手写 bind 函数](https://juejin.im/post/6844904056431837197)
        ```js
        Function.prototype.myBind = function (context = window) {
            var argumentsArr = Array.prototype.slice.call(arguments) // 类数组转数组
            var args = argumentsArr.slice(1) // 后面的参数
            var self = this // fn1.bind(...) 中的 fn1
            return function () { // 返回一个待执行的方法
                var newArgs = Array.prototype.slice.call(arguments) // fn1.bind()(args)  接收 args 参数
                self.apply(context, args.concat(newArgs)) // 合并两 args
            }
        }
        ```
        ```js
        //  测试
        var name = 'window name'
        var obj = {
            name: 'obj name',
        }
        var fn = function () {
            console.log(this.name, [...arguments])
        }
        fn(1, 2, 3, 4) // 直接执行，this指向window
        fn.myBind(obj, 1, 2)(3, 4) // mybind改变this指向
        fn.bind(obj, 1, 2)(3, 4) // 原生bind

        // 以上执行结果如下：
        // window name [1, 2, 3, 4]
        // obj name [1, 2, 3, 4]
        // obj name [1, 2, 3, 4]
        ```
        - 因为 bind() 可接收的参数 是不确定的，可能只有一个 两个，也可能有100个。
            - 那么问题来了，如何解决这个参数接收的问题？
        - `arguments` 可以获取 所有传入的参数。但是他是一个 类数组对象，不是数组，所以这里把他转为数组
            - `const args = Array.prototype.slice.call(arguments)` 通过这种方式 就可以把 类数组对象 变为 数组
            ```js
            var args = Array.from(arguments) // 类数组转数组(es6) 
            console.log(args instanceof Array) // true
            ```
        - 参考：[类数组（Array-like）对象, `Array.prototype.slice.call()` 使用方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)
            - `Array.prototype.slice.call()` 用来将一个类数组（Array-like）对象/集合转换成一个新数组
        - [什么是 **类数组对象** ？【掘金】](https://juejin.im/post/6844903711022514184)
            ```js
            var arrLike = {
                0: 'name',
                1: 'age',
                2: 'job',
                length: 3
            }
            ```
            - 那么我们希望类数组对象能够和数组一样使用数组的方法，应该怎么做呢？我们一般是通过 Function.call 或者 Function.apply 方法来间接调用。
            ```js
            // 使用 call
            Array.prototype.push.call(arrLike, 'hobby');
            console.log(arrLike); // { '0': 'name', '1': 'age', '2': 'job', '3': 'hobby', length: 4 }

            var arrLikeStr = Array.prototype.join.call(arrLike, '&')
            console.log(arrLikeStr); // name&age&job&hobby
            ```
            ```js
            // 使用 apply
            Array.prototype.push.apply(arrLike, ['hobby']);
            console.log(arrLike); // { '0': 'name', '1': 'age', '2': 'job', '3': 'hobby', length: 4 }

            var arrLikeStr = Array.prototype.join.apply(arrLike, ['&'])
            console.log(arrLikeStr); // name&age&job&hobby
            ```


- ## [JavaScript 中 call()、apply()、bind() 的用法](https://www.runoob.com/w3cnote/js-call-apply-bind.html)
    - 其实是一个很简单的东西，认真看十分钟就从一脸懵B 到完全 理解！
    - 先看明白下面：
    - **例1：**
        ```js
        var name = '小王', age = 17
        var obj = {
            name: '小张',
            objAge: this.age,
            myFun: function () {
                console.log( this.name + '年龄' + this.age )
            }
        }
        ```
        ```js
        obj.objAge;  // 17
        obj.myFun()  // 小张年龄 undefined
        ```
    - **例2：**
        ```js
        var fav = '盲僧'
        function shows() {
            console.log(this.fav)
        }
        ```
        ```js
        shows()  // 盲僧　
        ```
    - 比较一下 上面 例1 例2 这两者 this 的差别，第一个打印里面的 this 指向 obj，第二个全局声明的 shows() 函数 this 是 window ；
    - ###  **1.call()、apply()、bind() 都是用来重定义 this 这个对象的！**
        ```js
        var name = '小王', age = 17;
        var obj = {
            name: '小张',
            objAge: this.age,
            myFun: function () {
                console.log( this.name + '年龄' + this.age )
            }
        }
        var db = {
            name: '德玛',
            age: 99
        }
        ```
        ```js
        obj.myFun.call(db)；　　　　// 德玛年龄 99
        obj.myFun.apply(db);　　　 // 德玛年龄 99
        obj.myFun.bind(db)();　　　// 德玛年龄 99
        ```
        以上除了 bind 方法后面多了个 () 外 ，结果返回都一致！

        由此得出结论，bind 返回的是一个新的函数，你必须调用它才会被执行。

        > call()、apply()、bind() 都是用来重定义 this 这个对象的！ <br>
        > call()、apply()、bind() 都是 **引用了原函数的结构 (处理逻辑)，但是却使用了新的this** <br>
        > call()、apply()、bind() 都是 **引用了原函数的结构 (处理逻辑)，但是this却指向了传入的对象**
        - 用上面 第3句话，一句话记住 `call()、apply()、bind()` 的用法

        <br>
        <br>

        - 最后再看 [官方定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function)
            - `Function.prototype.call()`
            - 在一个对象的上下文中应用另一个对象的方法；
        - 如何理解？举个例子
            - `obj.myFun.call(db)`
            - 在 db 对象的上下文中，应用 `obj.myFun` 这个方法
    - **2.对比call 、bind 、 apply 传参情况下**
        ```js
        var name = '小王', age = 17;
        var obj = {
            name: '小张',
            objAge: this.age,
            myFun: function (fm, t) {
                console.log( this.name + '年龄' + this.age, ' 来自 ' + fm + '去往' + t )
            }
        }
        var db = {
            name: '德玛',
            age: 99
        }
        ```
        ```js
        obj.myFun.call(db,'成都','上海')；　　　　 // 德玛 年龄 99  来自 成都去往上海
        obj.myFun.apply(db,['成都','上海']);      // 德玛 年龄 99  来自 成都去往上海  
        obj.myFun.bind(db,'成都','上海')();       // 德玛 年龄 99  来自 成都去往上海
        obj.myFun.bind(db,['成都','上海'])();　　 // 德玛 年龄 99  来自 成都, 上海去往 undefined
        ```
        微妙的差距！

        从上面四个结果不难看出:

        call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象，第二个参数差别就来了：

        call 的参数是直接放进去的，第二第三第 n 个参数全都用逗号分隔，直接放到后面 `obj.myFun.call(db,'成都', ... ,'string' )`。

        apply 的所有参数都必须放在一个数组里面传进去 `obj.myFun.apply(db,['成都', ..., 'string' ])`。

        bind 除了返回是函数以外，它 的参数和 call 一样。

        当然，三者的参数不限定是 string 类型，允许是各种类型，包括函数 、 object 等等！


# 第05章 JS基础-异步【三座大山之三，必考！！！】
## 5-1 同步和异步的区别
- 问题
    ```js
    - 同步 和 异步 的区别是��么？
        - 为什么会有异步？ 为什么要用异步？ 为什么不能 直接用同步？

    - 手写用 Promise 加载一张图片
        - 考察 Promise 语法问题

    - 前端使用异步有哪些场景？
        - 考察这个问题，是要看你 是否真的用过异步，或者是否有实际的 项目开发经验
    ```
- 题目
    ```js
    // setTimeout 笔试题
    console.log(1)
    setTimeout(function(){
        console.log(2)
    }, 1000)
    console.log(3)
    setTimeout(function(){
        console.log(4)
    }, 0)
    console.log(5)
    ```
- 知识点
    - 单线程 和 异步
        - 为什么会有异步？
            - JS 是单线程语言，只能同时做一件事
                - 同时只能只一件事：如 我去做一个 ajax请求 / 加载一张图片 / 等待定时器，在请求没做完的过程中，页面就会卡死，鼠标也不能 移动/点击
                - 如果说，你想在 这个过程中，想再去做另一件事情，如 滚动 / 点击 / 动画卡住 / 点击一个图片 /  打印一个东西 / 执行其他JS，不好意思 这个做不到。这就是 单线程语言
            - 浏览器 和 Node.js 已支持JS启动 **进程**，如 Web Worker / Node.js 多进程 API
                - 它能启动进程，但是不能改变 JS是单线程语言 的本质
            - JS 和 DOM渲染 公用 同一个线程，因为 JS 可以修改 DOM结构
                - **JS 和 DOM渲染 互相阻塞，因为同时 只能让他们中的一个 执行**
        - 遇到等待（网络请求，定时任务）不能卡住。
        - 这时候，就 **需要异步**。 **异步就是用来解决单线程等待的问题**。
        - 异步借助 callback 函数形式 实现

    - 应用场景 是什么？

    - Promise 和 callback hell
        - Promise 就是解决了 callback hell 回调地狱 的问题

- 异步和同步
    ```js
    // 异步
    console.log(100)
    setTimeout(function(){
        console.log(200)
    }, 1000)
    console.log(300)
    ```
    ```js
    // 同步
    console.log(100)
    alert(200)       // 同步 会卡住，后面的东西 不会执行
    console.log(300)
    ```
    > 基于JS是单线程语言，异步不会阻塞代码执行，同步会阻塞代码执行 <br>
    > 因为 JS是单线程的，但是你又要 做那些需要等待才能完成的任务，**所以 只能发明异步 这种解决方案**

## 5-2 应用场景
- 什么情况下 需要异步呢？
    - 就是那些需要等待的情况
        - 网络请求，如 ajax, 图片加载
        - 定时任务，如 setTimeout, setInterval

        ```js
        // ajax
        console.log('start')
        $.get('./data.json', function(data){
            console.log(data)
        })
        console.log('end')
        ```
        ```js
        // 图片加载
        console.log('start')
        let img = document.createElement('img')
        img.onload = function(){
            console.log('img loaded')
        }
        img.src = './xxx.png'
        console.log('end')
        ```
        ```js
        // 定时器 setTimeout
        console.log(100)
        setTimeout(function(){
            console.log(200)
        }, 1000)
        console.log(300)
        ```
        ```js
        // 定时器 setInterval
        console.log(100)
        setInterval(function(){
            console.log(200)
        }, 1000)
        console.log(300)
        ```

## 5-3 promise
- Promise 就是解决了 callback hell 回调地狱 的问题
- callback hell 回调地狱
    ```js
    // 获取第一份数据
    $.get(url1, function(data1){
        console.log(data1)

        // 获取第二份数据
        $.get(url2, function(data2){
            console.log(data2)

            // 获取第三份数据
            $.get(url3, function(data3){
                console.log(data3)

                // 还可以能 获取更多数据
            })
        })
    })
    ```
- 因为回调地狱非常的麻烦，代码的可阅读性差，可维护性差，所以这时候 就需要 解决这个问题。 **这时候 Promise 就诞生了**
    - Promise 就是解决了 callback hell 回调地狱 的问题
- Promise
    ```js
    function getData(url){
        return new Promise((resolve, reject) => {
            $.ajax({
                url,
                success(data){
                    resolve(data)
                },
                error(err){
                    reject(err)
                }
            })
        })
    }
    ```
    ```js
    const url1 = '/data1.json'
    const url2 = '/data2.json'
    const url3 = '/data3.json'

    getData(url1).then(data1 => {
        console.log(data1)
        return getData(url2)
    }).then(data2 => {
        console.log(data2)
        return getData(url3)
    }).then(data3 => {
        console.log(data3)
    }).catch(err => console.log(err))
    ```


## 5-4 问题解答和总结
- 问题解答
    - 同步和异步的区别到底是什么？
        - 答：基于JS是单线程语言，异步不会阻塞代码执行，同步会阻塞代码执行

    - 手写 Promise 加载一张图片
        ```js
        // 定义函数
        function loadImg (src) {
            return new Promise( (resolve, reject) => {
                const img = document.createElement('img')
                img.onload = () => {
                    resolve(img)
                }
                img.onerror = () => {
                    const err = new Error(`图片加载失败 ${src}`)
                    reject(err)
                }
                img.src = src
            } )
        }

        const url = 'https://imgUrl/1.jpg'

        loadImg(url).then(img => {
            console.log(img.width)
            return img
        }).then(img => {
            console.log(img.height)
        }).catch(err => console.error(err))
        ```
        ```js
        
        const url1 = 'https://imgUrl/1.jpg'
        const url2 = 'https://imgUrl/2.jpg'

        loadImg(url1).then(img1 => {
            console.log(img1.width)
            return img1             // return 普通对象
        }).then(img1 => {
            console.log(img1.height)
            return loadImg(url2)    // return Promise 对象
        }).then(img2 => {
            console.log(img2.width)
            return img2
        }).then(img2 => {
            console.log(img2.height)
        }).catch(err => console.error(err))
        ```
## 5-5 JS基本知识-总结
```js
- 变量类型和计算 - 题目
    - typeof 能判断哪些类型
    - 何时使用 === , 何时使用 ==
    - 值类型 和 引用类型
    - 手写深拷贝

- 变量类型和计算 - 知识点
    - 值类型 vs 引用类型，堆栈模型，深拷贝
    - typeof 运算符
    - 类型转换，truly 和 falsely 变量




- 原型和原型链 - 题目
    - 如何准确判断一个变量是不是数组？ （instanceof）
    - 手写一个简易的 jQuery ，考虑插件 和 扩展性
    - Class 的原型本质，怎么理解？（原型和原型链）

- 原型和原型链 - 知识点
    - Class 和 继承，结合手写 jQuery 的示例来理解
    - instanceof
    - 原型和原型链：图示 & 执行规则




- 闭包和作用域 - 题目
    - this 的不同应用场景，如何取值？
    - 手写 bind 函数
    - 实际开发中 遇到闭包的场景，举例说明
- 闭包和作用域 - 知识点
    - 作用域和自由变量
    - 闭包：两种常见方式 & 自由变量的查找规则
    - this



- 异步和单线程 - 题目
    - 同步和异步的区别是什么？
    - 手写 Promise 加载一张图片
    - 前端使用异步的场景有哪些？
    - setTimeout 执行顺序
- 异步和单线程 - 知识点
    - 单线程和异步，异步和同步的区别
    - 前端异步的应用场景：网络请求 & 定时任务
    - Promise 解决 callback hell
```


# 第06章 JS-Web-API-DOM【学会DOM，才能具备网页开发的基础】
## 6-1 从JS基础到JS Web API
- JS 基础知识，规定语法 ( ECMA 262 标准 )
- JS Web Api，网页操作的 API ( W3C 标准 )
    - W3C 标准
        - Html 标准
        - CSS 标准
        - JS Web Api 标准 (如何使用 JS 操作网页)
        - 网络请求/Ajax 标准
        - 存储标准
        - ...
- JS Web Api 有哪些内容？
    - DOM
        - DOM 操作，如操作 文本、图片...
    - BOM
        - BOM 操作，就是操作浏览器的事件，如 导航、URL地址、浏览器的跳转、浏览器的宽高
    - 事件绑定
        - 绑定一个事件，监听一个点击，...
    - Ajax
    - 存储

## 6-2 DOM的本质
- 前言
    - vue 和 react 框架应用，封装了 DOM 操作，所以你不用进行 DOM操作
    - 但 DOM 操作一直都是 前端工程师的基础、必备知识
    - 只会 vue 而不懂 DOM操作 的前端程序员，不会长久
    - DOM是浏览器的组成部分，会一直存在，而 Vue React 框架 长则10年，最终还是有可能会被淘汰的。所以DOM 还是核心技术

- DOM 是什么？
    - DOM 是 Document Object Model 的简称

```
- 题目
    - DOM 是哪种数据结构？

    - DOM 操作的常用 API

    - attr 和 property 的区别 （它们都叫属性）

    - 一次性插入多个 DOM 节点，考虑性能
```

- 知识点
    - DOM 本质是什么？
    - DOM 节点操作
    - DOM 结构操作
    - DOM 性能问题
        - DOM 操作 是比较耗性能、耗CPU 的，如何解决这种问题？

- DOM的本质
    - DOM的本质 得从 XML 说起，XML 是一种 **`可扩展的标记性语言`**
        - **`可扩展`** 值的是，它可以描述任何结构的数据，它是一棵树
        - XML 可以任意定义标签，可以任意扩展 ( 类似于 JSON )
    - ### HTML 是什么？
        - HTML 其实是一种特定的 XML
        - 它做了规范，规定了 XML 的书写规范，规定了 标签名，如 `head` `body` `div` ... 分别是用于 某种 特定情况的

- XML
    ```xml
    <?xml version='1.0' encoding='utf-8'?>
    <note>
        <to>Tove</to>
        <from>Jani</from>
        <heading>Reminder</heading>
        <body>Don't forget me this weekdnd!</body>
        <other>
            <a></a>
            <b></b>
        </other>
    </note>
    ```
- HTML
    ```html
    <!DOCTYPE html>
    <html>
        <head>
            <meta charset='utf-8'>
            <title>Document</title>
        </head>
        <body>
            <div>
                <p>this is p</p>
            </div>
        </body>
    </html>
    ```
    ![](./img/0.interview-question/15.jpg)
    - HTML 代码 下载到 浏览器，浏览器 解析 就会生成 DOM结构
- ### HTML 和 DOM 的区别
    > HTML 是一个文件 或 代码 <br>
    > DOM 是 浏览器 内存里 已经初始化好 的 **`一个树的结构`**

## 6-3 DOM节点操作
- 获取 DOM 节点
- attribute
- property

<br><br>

- ### 获取 DOM 节点
    ```js
    const div1      = document.getElementById('div1')              // 元素
     
    const divList   = document.getElementsByTagName('div')         // 集合
    const container = document.getElementsByClassName('container') // 集合
    const headList  = document.querySelectorAll('.heading')               // 集合
    ```
    只有 `querySelectorAll()` 传入的是 CSS选择器
    ```js
    document.querySelectorAll('p')        // tagName
    document.querySelectorAll('.heading') // className
    document.querySelectorAll('#head')    // idName

    → document.querySelectorAll('.heading')
    ↓ NodeList(5) [h3.heading, h3.heading, h3.heading, h3.heading, h3.heading]
        0: h3.heading
        1: h3.heading
        2: h3.heading
        3: h3.heading
        4: h3.heading
        length: 5
        __proto__: NodeList
    ```
- ### DOM 节点的 property
    - property 它本身不是一个 API
    - 属性访问器提供了两种方式用于访问一个对象的属性，它们分别是点号和方括号
    - property 语法
        ```js
        object.property
        object['property']
        ```
    ```js
    const pList = ducument.querySelectorAll('p')
    const p1 = pList[0]

    // property 形式
    p1.style.width = '100px'
    console.log( p1.style.width )  // '100px'
    p1.className = 'red'
    console.log( p1.className )  // 'red'
    console.log( p1.nodeName )   // 'p'
    console.log( p1.nodeType )   // 1

    document.querySelectorAll('.md-tile')[0]['style']['width'] // "100px"
    document.querySelectorAll('.md-tile')[0].style.width       // "100px"
    ```
- ### attribute
    - `attribute` 通过 `setAttribute()` 和 `getAttribute()` 来设置和读取
    ```js
    p1.setAttribute('data-name', 'imooc')   // 设置属性
    p1.getAttribute('data-name') // 'imooc' // 读取属性
    ```
    ```html
    <p data-name="imooc">一段文字</p>
    ```
- Attribute 和 Property 的区别
> property： 修改对象属性，不会体现到 html 结构中，不会对 DOM 产生什么影响，只是在 js变量内存中 产生影响 <br><br>
> attribute：修改 html 属性，会改变 html 结构，是真的能够修改 DOM 标签的属性 （除了 className 和 ID ）<br><br>
> 两者都有可能引起 DOM 重新渲染 <br><br>
> 建议优先使用 property

- ### [Attribute VS Property 的区别](https://juejin.im/post/6844903712721387534)
    - 首先，这两个是非常相像的东西
    - 区别
        ```html
        <input id="the-input" type="typo" value="Name:" /> // 在页面加载后,
        我们在这个input中输入 "Jack"
        ```
        让我们来看看上面这个 input 节点的 attribute 和 property:
        ```js
        // attribute still remains the original value
        input.getAttribute('id') // the-input
        input.getAttribute('type') // typo
        input.getAttribute('value') // Name:

        // property is a different story
        input.id // the-input
        input.type //  text
        input.value // Jack
        ```
        - 可以看到, 在 attribute 中, 值仍然是 html 代码中的值. 
        - 而在 property 中, type 被自动修正为了 text, 而 value 随着用户改变 input 的输入, 也变更为了 Jack
        <br><br><br>

        - 这就是 attribute 和 Property 间的区别:
            - **`attribute 会始终保持 html 代码中的初始值`**
            - **`Property 是有可能变化的.`**

        - 其实, 我们从这两个单词的名称也能看出些端倪:
            - attribute 从语义上, 更倾向于不可变更的
            - 而 property 从语义上更倾向于在其生命周期中是可变的

    - Attribute or Property 可以自定义吗?
        - 先说结论: attribute 可以 property 不行
        - 我们可以尝试在 html 中自定义 attribute:
        ```html
        <input value="customInput" customeAttr="custome attribute value" />
        ```
        然后我们尝试获取自定义的属性:
        ```html
        input.getAttribute('customAttr') // custome attribute value
        input.customAttr // undefined
        ```
        可以看到, 我们能够成功的获取自定义的 attribute, 但是无法获取 property.

        - 其实不难理解
            - DOM 节点在初始化的时候会将html 规范中定义的 attribute 赋值到 property 上, 
            - 而自定义的 attribute 并不属于这个氛围内, 自然生成的 DOM 节点就没有这个 property.


## 6-4 DOM结构操作
```
- DOM 结构常见操作
    - 新增/插入节点
    - 获取子元素列表，获取父元素
    - 删除子元素
```
- ### 新增/插入节点
    ```js
    const div1 = document.getElementById('div1')
    // 添加新节点
    const p = document.createElement('p')
    p.innerHTML = 'this is p'
    div1.appendChild(p)

    // 移动已有节点。注意是移动！！！
    const p2 = document.getElementById('p2')
    div1.appendChild(p2)
    ```
- ### 获取子元素列表，获取父元素
    ```js
    // 获取子元素列表
    const div1  = document.getElementById('div1')
    const child = div1.childNodes

    // 获取父元素
    const div1  = document.getElementById('div1')
    const parent = div1.parentNode
    ```
- ### 删除子元素
    ```js
    const div = document.getElementById('div1')
    const child = div.childNodes
    div.removeChild(child[0])
    ```


## 6-5 DOM性能
- DOM性能
    ```js
    - DOM 操作非常 "昂贵"，避免频繁的 DOM操作

    - 对 DOM 查询做缓存

    - 将频繁操作改为一次性操作
    ```
- ### 对 DOM 查询做缓存
    ```js
    // 不缓存 DOM 查询结果
    for (let i = 0; i < document.getElementsByTagName('p').length; i++) {
        // 每次循环 都会计算 length，频繁进行 DOM 查询
    }


    // 缓存 DOM 查询结果
    const pList = document.getElementsByTagName('p')
    const length = pList.length
    for (let i = 0; i < length; i++) {
        // 缓存 length ，只进行一次 DOM 查询
    }
    ```
- ### 将频繁 DOM操作 改为一次性操作
    ```js
    const listNode = document.getElementById('list')
    
    // 创建一个文档片段，此时还没有插入到 DOM 树中
    const frag = document.createDocumentFragment()

    // 执行插入
    for (let x = 0; x < 10; x++) {
        const li = document.createElement('li')
        li.innerHTML = 'List item ' +　ｘ
        frag.appendChild(li)
    }

    // 都完成后，再插入到 DOM 树中
    listNode.appendChild(frag)
    ```
    - [什么是 `Document.createDocumentFragment()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createDocumentFragment)
        - `fragment` 是一个指向空 `DocumentFragment` 对象的引用。
        - `DocumentFragments` 是DOM节点。它们不是主DOM树的一部分。
            - 通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。
            - 在DOM树中，文档片段被其所有的子元素所代替。
        - 因为文档片段存在于 **内存中**，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。
        > 回流：当浏览器必须重新处理和绘制部分或全部页面时，回流就会发生，例如当一个交互式站点更新后。


## 6-6 问题解答和小结
- 问题
    - 1
        - DOM 是哪种数据结构
        - DOM 操作的常用API
        - attr 和 property 的区别
    - 2
        - DOM节点操作
        - DOM结构操作
        - `attribute 操作` 和 `property 操作`
    - 一次性插入多个节点，考虑性能


- 解答
    - DOM 是哪种数据结构
        - 树 （DOM 树）。树形数据结构


# 第07章 JS-Web-API-BOM【内容虽然不多，但是你不能不会】
## 7-1 题目知识点和解答
- BOM 操作 ( Browser Object Model )

```
- 题目
    - 如何识别浏览器的类型
        - 识别 微信、微博、QQ浏览器...
        - 还有的 浏览器 自我隐藏，隐藏自己的浏览器信息，做的和别的浏览器信息一模一样

    - 分析拆解 url 各个部分
        - 协议、host、path、search
```

- 知识点
    - navigator
    - screen
    - location
    - history

    
- 知识点
    - navigator
        - 浏览器的信息
    - screen
        - 屏幕的信息
    - location
        - 地址的信息
    - history
        - 前进后退的信息

- ### navigator
    ```js
    // navigator
    const ua = navigator.userAgent
    const isChrome = ua.indexOf('Chrome')
    console.log(isChrome)


    → navigator.userAgent
    ← "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36"
    ```
    - ua 里 混了 许多不同浏览器的 关键字，如 Mozilla 是 FireFox，Chrome，Safari
    - 具体 "各个浏览器 的 UA检查方案" 要自己搜索。也可以参照下面文章

- ### [详细判断浏览器运行环境 【掘金】](https://juejin.im/post/6844903874113830920)
    - 浏览器相关统计数据可以参考这里。[gs.statcounter.com/browser-market-share](https://gs.statcounter.com/browser-market-share/mobile/china)
    - 一个文件实现 浏览器运行环境判断 [browser-type.js](https://github.com/JowayYoung/juejin-code/blob/master/browser-type.js)
    ```js
    export default function BrowserType() {
        // 权重：系统 + 系统版本 > 平台 > 内核 + 载体 + 内核版本 + 载体版本 > 外壳 + 外壳版本
        const ua = navigator.userAgent.toLowerCase();
        const testUa = regexp => regexp.test(ua);
        const testVs = regexp => ua.match(regexp)
            .toString()
            .replace(/[^0-9|_.]/g, "")
            .replace(/_/g, ".");
        // 系统
        let system = "unknow";
        if (testUa(/windows|win32|win64|wow32|wow64/g)) {
            system = "windows"; // windows系统
        } else if (testUa(/macintosh|macintel/g)) {
            system = "macos"; // macos系统
        } else if (testUa(/x11/g)) {
            system = "linux"; // linux系统
        } else if (testUa(/android|adr/g)) {
            system = "android"; // android系统
        } else if (testUa(/ios|iphone|ipad|ipod|iwatch/g)) {
            system = "ios"; // ios系统
        }
        // 系统版本
        let systemVs = "unknow";
        if (system === "windows") {
            if (testUa(/windows nt 5.0|windows 2000/g)) {
                systemVs = "2000";
            } else if (testUa(/windows nt 5.1|windows xp/g)) {
                systemVs = "xp";
            } else if (testUa(/windows nt 5.2|windows 2003/g)) {
                systemVs = "2003";
            } else if (testUa(/windows nt 6.0|windows vista/g)) {
                systemVs = "vista";
            } else if (testUa(/windows nt 6.1|windows 7/g)) {
                systemVs = "7";
            } else if (testUa(/windows nt 6.2|windows 8/g)) {
                systemVs = "8";
            } else if (testUa(/windows nt 6.3|windows 8.1/g)) {
                systemVs = "8.1";
            } else if (testUa(/windows nt 10.0|windows 10/g)) {
                systemVs = "10";
            }
        } else if (system === "macos") {
            systemVs = testVs(/os x [\d._]+/g);
        } else if (system === "android") {
            systemVs = testVs(/android [\d._]+/g);
        } else if (system === "ios") {
            systemVs = testVs(/os [\d._]+/g);
        }
        // 平台
        let platform = "unknow";
        if (system === "windows" || system === "macos" || system === "linux") {
            platform = "desktop"; // 桌面端
        } else if (system === "android" || system === "ios" || testUa(/mobile/g)) {
            platform = "mobile"; // 移动端
        }
        // 内核和载体
        let engine = "unknow";
        let supporter = "unknow";
        if (testUa(/applewebkit/g)) {
            engine = "webkit"; // webkit内核
            if (testUa(/edge/g)) {
                supporter = "edge"; // edge浏览器
            } else if (testUa(/opr/g)) {
                supporter = "opera"; // opera浏览器
            } else if (testUa(/chrome/g)) {
                supporter = "chrome"; // chrome浏览器
            } else if (testUa(/safari/g)) {
                supporter = "safari"; // safari浏览器
            }
        } else if (testUa(/gecko/g) && testUa(/firefox/g)) {
            engine = "gecko"; // gecko内核
            supporter = "firefox"; // firefox浏览器
        } else if (testUa(/presto/g)) {
            engine = "presto"; // presto内核
            supporter = "opera"; // opera浏览器
        } else if (testUa(/trident|compatible|msie/g)) {
            engine = "trident"; // trident内核
            supporter = "iexplore"; // iexplore浏览器
        }
        // 内核版本
        let engineVs = "unknow";
        if (engine === "webkit") {
            engineVs = testVs(/applewebkit\/[\d._]+/g);
        } else if (engine === "gecko") {
            engineVs = testVs(/gecko\/[\d._]+/g);
        } else if (engine === "presto") {
            engineVs = testVs(/presto\/[\d._]+/g);
        } else if (engine === "trident") {
            engineVs = testVs(/trident\/[\d._]+/g);
        }
        // 载体版本
        let supporterVs = "unknow";
        if (supporter === "chrome") {
            supporterVs = testVs(/chrome\/[\d._]+/g);
        } else if (supporter === "safari") {
            supporterVs = testVs(/version\/[\d._]+/g);
        } else if (supporter === "firefox") {
            supporterVs = testVs(/firefox\/[\d._]+/g);
        } else if (supporter === "opera") {
            supporterVs = testVs(/opr\/[\d._]+/g);
        } else if (supporter === "iexplore") {
            supporterVs = testVs(/(msie [\d._]+)|(rv:[\d._]+)/g);
        } else if (supporter === "edge") {
            supporterVs = testVs(/edge\/[\d._]+/g);
        }
        // 外壳和外壳版本
        let shell = "none";
        let shellVs = "unknow";
        if (testUa(/micromessenger/g)) {
            shell = "wechat"; // 微信浏览器
            shellVs = testVs(/micromessenger\/[\d._]+/g);
        } else if (testUa(/qqbrowser/g)) {
            shell = "qq"; // QQ浏览器
            shellVs = testVs(/qqbrowser\/[\d._]+/g);
        } else if (testUa(/ucbrowser/g)) {
            shell = "uc"; // UC浏览器
            shellVs = testVs(/ucbrowser\/[\d._]+/g);
        } else if (testUa(/qihu 360se/g)) {
            shell = "360"; // 360浏览器(无版本)
        } else if (testUa(/2345explorer/g)) {
            shell = "2345"; // 2345浏览器
            shellVs = testVs(/2345explorer\/[\d._]+/g);
        } else if (testUa(/metasr/g)) {
            shell = "sougou"; // 搜狗浏览器(无版本)
        } else if (testUa(/lbbrowser/g)) {
            shell = "liebao"; // 猎豹浏览器(无版本)
        } else if (testUa(/maxthon/g)) {
            shell = "maxthon"; // 遨游浏览器
            shellVs = testVs(/maxthon\/[\d._]+/g);
        }
        return Object.assign({
            engine, // webkit gecko presto trident
            engineVs,
            platform, // desktop mobile
            supporter, // chrome safari firefox opera iexplore edge
            supporterVs,
            system, // windows macos linux android ios
            systemVs
        }, shell === "none" ? {} : {
            shell, // wechat qq uc 360 2345 sougou liebao maxthon
            shellVs
        });
    }
    ```

- ### screen
    ```js
    screen.width   // 1600
    screen.height  // 900
    ```
- ### location
    ```js
    location.href       // "https://juejin.im/post/684490?a=100&b=200#234123"
    location.protocol   // "https:" "http:"
    location.pathname   // "/post/684490"
    location.search     // "?a=100&b=200"
    location.hash       // "#234123"

    ↓ location
        Location {origin: "https://juejin.im", protocol: "https:", host: "juejin.im", …}
        hash: "#234123"
        host: "juejin.im"
        hostname: "juejin.im"
        href: "https://juejin.im/post/6844903874113830920"
        origin: "https://juejin.im"
        pathname: "/post/6844903874113830920"
        port: ""
        protocol: "https:"
        search: "?a=100&b=200"
        ...
    ```
- ### history
    ```js
    history.back()
    history.forward()
    ```

# 第08章 JS-Web-API-事件【事件不会，基本等于半残废，必考！必考！】
## 8-1 事件绑定和事件冒泡
```
- 题目
    - 编写一个通用的事件监听函数

    - 描述事件冒泡的流程

    - 无限下拉的图片列表，如何监听每个图片的链接？
```

- 题目 解析
    - 编写一个通用的事件监听函数
        - 绑定事件时，可能会有各种各样的情况，你要考虑各种情况

    - 描述事件冒泡的流程
        - 一层一层 往上冒泡
        - 下层节点 触发，上层节点 截获

    - 无限下拉的图片列表，如何监听每个图片的链接？
        > 像这种题，它不告诉你知识点是什么，然后让你自己 去找知识点，去解决。实际工作中 也是这样

- 知识点
    - 事件绑定
    - 事件冒泡
    - 事件代理

- ### 事件绑定
    ```js
    const btn = document.getElementById('btn1')
    btn.addEventListener('click', event => {
        console.log('clicked')
    })
    ```
    ```js
    // 通用事件监听函数
    function bindEvent (elem, type, fn) {
        elem.addEventListener(type, fn)
    }

    const a = document.getElementById('link1')
    bindEvent(a, 'click', e => {
        // e.target // 获取触发的元素
        e.preventDefault()  // 阻止默认行为
        alert('clicked')
    }){}
    ```

- ### 事件冒泡
    ```js
    // 通用事件监听函数
    function bindEvent (elem, type, fn) {
        elem.addEventListener(type, fn)
    }

    const p = document.getElementById('p1')
    const body = document.body
    bindEvent(p, 'click', e => {
        e.stopPropagation() // 注释掉这一行，来体会事件冒泡
        alert('激活')
    })
    bindEvent(body, 'click', e => {
        alert('取消')
    })
    ```
    ```html
    <body>
        <div id='div1'>
            <p id='p1'>激活</p>
            <p id='p2'>取消</p>
            <p id='p3'>取消</p>
            <p id='p4'>取消</p>
        </div>
        <div id='div2'>
            <p id='p5'>激活</p>
            <p id='p6'>取消</p>
        </div>
    </body>
    ```

## 8-2 事件代理
- ### 事件代理
    - 什么是事件代理？
        - 事件代理，就是 事件本身 不绑定在 触发对象 `event.target` 上，而是 绑定在其他对象上（在其他对象监听）。我们称之为 事件代理。（代理给第三方）
        - 举个例子：
            - > 无限下拉的图片列表，如何监听每个图片的链接？
            - 我们不在 列表项 的每一项上，监听事件，而是在他的 上一级（父元素）上绑定 监听事件。代码如下
    ```html
    <div id='div1'>
        <a id='a1'>激活</a>
        <a id='a2'>取消</a>
        <a id='a3'>取消</a>
        <a id='a4'>取消</a>
    </div>
    <button>点击增加一个a标签</button>
    ```
    ```js
    // 这里的实现逻辑，是基于事件冒泡，这样才能在上级元素去监听事件

    const div = document.getElementById('div1')
    div.addEventListener('click', e => {
        e.preventDefault()
        const target = e.target
        // console.dir(target.nodeName)
        if (target.nodeName === 'A'){
            alert(target.innerHTML)
        }
    })
    ```
    - #### 事件代理 的优点
        - 代码简洁
            - 如果你给 a标签，每一个都做事件绑定，你要至少 还要做 DOM查询、循环
        - 减少浏览器内存占用
            - 如果给里面 每一个 a标签 都挂一个事件监听，这样是非常耗费内存的
        - 但是，不要滥用 事件代理
            - 事件代理 还是有一定 **`复杂度`** 的
            - 虽然他的 代码简洁，但是这是相对的。是相对于 给每个 子项都做事件监听 而言，来的更简洁而已
            - > 所以 事件代理 的使用场景，一般只在 子项非常多，而不便于每个 子项都做事件监听 的情况下 才会使用

- ### 通用事件监听函数 优化版
    - 我们上面所写的 **`通用事件监听函数`** 太过于简单了，如果是那么简单的话 面试中 也没必要考了
    ```js
    // 通用事件监听函数
    function bindEvent (elem, type, fn) {
        elem.addEventListener(type, fn)
    }
    ```
    - 我们应该考虑到，更多的情况，如 `事件代理` 的情况
    ```js
    // 通用事件监听函数 - 优化

    /*
     * elem 监听元素
     * type 事件监听类型
     * selector
     * fn 回调函数
     */
    function bindEvent (elem, type, selector, fn) {
        if (fn == null) {   // 如果是传入3个参数的情况
            fn = selector
            selector = null
        }

        elem.addEventListener(type, e => {
            const target = e.target
            if (selector) {
                // 事件代理 情况
                if (target.matches(selector)) {  // Element.matches(selectorString) 方法。判断 target 是否是 你要绑定的那一个
                    fn.call(target, e)
                }
            } else {
                // 普通绑定
                fn.call(target, e)
            }
        })
    }
    ```
    - 调用函数
    ```html
    <div id='div1'>
        <p id='p1'>激活</p>
        <a id='a2'>取消</a>
        <a id='a3'>取消</a>
        <a id='a4'>取消</a>
    </div>

    <script>
        const box = document.getElementById('div1')

        // 事件代理 情况
        bindEvent(box, 'click', 'a', e => {
            console.log('代理对象', e.target)
            console.log('clickeed')
        })

        // 普通绑定
        bindEvent(box, 'click', e => {
            console.log(e.target)
            console.log('clickeed')
        })
    </script>

    ```
## 8-3 问题答疑和小结

```
- 题目
    - 编写一个通用的事件监听函数

    - 描述事件冒泡的流程

    - 无限下拉的图片列表，如何监听每个图片的链接？
```
- ### 描述事件冒泡的流程
    - 基于DOM树形结构
    - 事件会顺着触发元素往上冒泡
    - 应用场景：代理

- ### 无限下拉的图片列表，如何监听每个图片的链接？
    - 事件代理
    - 用 `e.target` 获取触发元素
    - 用 `Element.matches(selectorString)` 来判断是否是触发元素






# 第09章 JS-Web-API-Ajax【每个工程师必须熟练掌握的技能】
```
- 题目
    - 手写一个简易的 ajax
    - 跨域的常用实现方式
```

- 题目 解析
    - 手写一个简易的 ajax
        - 我们常见的三种 ajax 工具：jQuery、浏览器的 Fetch、Vue里用的 Axios
        - 工作中 不会让你去自己写 ajax，但是你要知道其中的原理，它是利用了那些api

```
- 知识点
    - XMLHttpRequest

    - 状态码：readyState status

    - 跨域：同源策略（如何绕过），跨域解决方案，JSONP，CORS
```

## 9-1 XMLHttpRequest
- ### XMLHttpRequest
    - GET 请求
        ```js
        const xhr = new XMLHttpRequest()
        xhr.open('GET', '/api', true)  // true 是异步请求, 默认为true  // .open() 时，数据还未发送
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    console.log( JSON.parse(xhr.responseText) )
                }
            }
        }
        xhr.send(null)  // 发送请求  // 因为它是 get请求 ，不用发生任何数据，所以发送null 就行
        ```
    - POST 请求
        ```js
        const xhr = new XMLHttpRequest()
        xhr.open('POST', '/login', true)
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    alert(xhr.responseText)
                } else {
                    console.log('其它情况')
                }
            }
        }
        const postData = {
            userName: 'nick',
            password: '123'
        }
        xhr.send(JSON.stringify(postData))  // 把他变成字符串 发送出去。这里不能发送 JSON ！！！
        ```
- ### xhr.readyState
    ```
    - xhr.readyState
        0 - ( 未初始化 ) 还没有调用 send() 方法
        1 - ( 载入 ) 已调用 send() 方法, 正在发送请求
        2 - ( 载入完成 ) send() 方法执行完成，已经接收到全部响应内容
        3 - ( 交互 ) 正在解析响应内容
        4 - ( 完成 ) 响应内容解析完成，可以在客户端调用
    ```
    除了第4种情况，其他任何情况，我们都拿不到 `xhr.responseText`

- ### xhr.status / HTTP状态码
    ```
    - xhr.status
        2xx - 表示成功处理，如 200


        3xx - 需要重定向，浏览器直接跳转，如 301 302 304
            - 重定向 不用我们自己处理，浏览器会根据 状态码 自动跳转

            - 301 永久重定向
                - 浏览器经过一次 301 后，以后每次访问该地址，浏览器会直接跳到 对应地址

            - 302 临时重定向
                - 如果返回302，浏览器会临时跳转一下，下次访问的时候 会再次访问原地址

            - 304 资源未改变
                - 如果返回 304 浏览器会使用 缓存的资源，而不是去请求网络资源。在做性能优化时 会常用到


        4xx - 客户端请求错误，如 404 403

            - 404 找不到，请求地址错误

            - 403 客户端没有权限，如 没有登陆

        
        5xx 服务器端错误
    ```

## 9-2 同源策略和跨域
```
- 问题
    - 什么是 跨域 ( 同源策略 )

    - JSONP

    - CORS ( 服务端支持 )
```

- ### 同源策略
    - 什么是同源策略？什么是 源？
        - > 同源：协议、域名、端口，三者必须一致
    - ajax 请求时，**`浏览器`** 要求当前网页和 server 必须同源 ( 安全 )

    - 加载 img, css, js 可以无视同源策略
        ```html
        <img src='跨域的 img地址'>

        <link href='跨域的 css地址'>

        <script scr='跨域的 js地址'></script>
        ```
    - `<img />` 可用于 **`统计打点`** ，可使用第三方统计服务
        - PV , UV , 按钮的点击次数..等 这些 **`统计打点`** 的东西，我们可以用图片来做
        - 也可以使用 第三方服务，如 站长之家、百度统计、谷歌统计...
        - **`统计打点`** 的本质 就是发送一个请求
            - > 原理：我们用一个图片，把图片的地址写成 第三方统计服务 的地址，然后在地址里写上 各种各样的参数，然后通过 图片去发送 这样的请求，这样就可以避免跨域的问题
            - 如果用 ajax 就会出现 跨域问题

    - `<link />` `<script>` 可使用 CDN，CDN一般都是外域

    - `<script>` 可实现 JSONP
        - > **`JSONP`** 是我们前端实现 跨域的一个常用方案

<br><br>

> <br>
> 所有的跨域，都必须经过 server 端的允许和配合 <br><br>
> 未经 server 端的允许 就实现跨域，说明浏览器有漏洞，危险信号 <br>
> <br>
<br>

## 9-3 jsonp和cors
- ### JSONP 跨域
    - `<script>` 可以绕过跨域
    - 服务器可以任意动态拼接数据返回
    - 所以，`<script>` 就可以获得跨域的数据，只要服务端 愿意返回

    ```html
    <!-- https://a.com/index.html -->

    <script>
        window.callback = function (data) {
            // data 是我们跨域得到的信息
            console.log(data)
        }
    </script>
    <script scr='https://b.com/getData.js'></script>
    ```
    ```js
    // https://b.com/getData.js

    callback(
        {username: 'nick', x: 100, y: 200}
    )
    ```
    - 1.当然，我们在 跨域请求 `getData.js` 可以在后面 带上参数
        - 这样 服务端 就可以读到 参数了
        - 就可以根据 不同的参数，动态拼接生成 不同的数据内容 返回
        ```js
        <script scr='https://b.com/getData.js?username=xxx'></script>
        ```
    - 2.`window.callback()` 这个函数名 也不是固定的
        - 我们同样可以在请求的时候，将 对应的函数名 拼接成 参数
        ```js
        <script scr='https://b.com/getData.js?username=xxx&callback=abc'></script>
        ```
        - 这样的话，后端就可以根据 你的命名，自动改成你想要的 函数名
        ```js
        // https://b.com/getData.js

        callback(
            {username: 'nick', x: 100, y: 200}
        )
        ```
    - 3.动态插入 `<script>` 进行跨域请求
        - 在 HTML 文件中，这个 `<script scr='https://b.com/getData.js'></script>` 可以不是写死的
        - 而是可以通过 我们 JS动态插入，在特定的时候 进行跨域请求的

    - 4.jQuery 实现 jsonp
        ```js
        $.ajax({
            url: 'http://localhost:8882/x-origin.json',
            dataType: 'jsonp',
            jsonpCallback: 'callback',

            // 请求成功的回调函数，json既为我们想要获得的数据
            success: function(json) {
                console.log(json);
            },
            // 请求失败的回调函数
            error: function(e) {
                alert("error");
            }
        })
        ```
        - 参数解析
            - url 等价于 `<script scr='https://b.com/getData.js?username=xxx&callback=abc'></script>`
            - dataType：告诉ajax 我们发送的不是 普通的ajax，而是 JSONP
                - 因为 ajax 内部实现逻辑是 基于 XMLHttpRequest 的
                - 而 JSONP 则是基于 `<script>` 跨域的，跟我们上面的实现 是一样的
            - jsonpCallback 就是 `callback=abc` 你定义的函数名
            - success 回调函数，就相当于 `window.callback = function () {}` 回调函数

- ### CORS
    - CORS 其实是一个统称
    - 服务器设置 http header
    - CORS 是一个纯服务端的东西
    ```js
    // 第二个参数填写允许跨域的域名称，不建议填写 "*"
    response.setHeader("Access-Control-Allow-Origin", "http://localhost:8011")
    response.setHeader("Access-Control-Allow-Headers", "X-Requested-With")
    response.setHeader("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS")

    // 接收跨域的 cookie
    response.setHeader("Access-Control-Allow-Credentials", "true")
    ```

## 9-4 问题解答
- 题目
    - 手写一个简易的 ajax
    - 跨域的常用实现方式
    
- ### 手写一个简易的 ajax
    ```js
    function ajax (url) {
        return new Promise( (resolve, reject) => {
            const xhr = new XMLHttpRequest()
            xhr.open('GET', url, true)
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        resolve( JSON.parse(xhr.responseText) )
                    } else if (xhr.status === 404) {
                        reject(new Error('404 not found'))
                    }
                }
            }
            xhr.send(null)
        })
    }

    let url = '/api/data.json'
    ajax(url)
        .then( data => console.log(data))
        .catch( err => console.error(err) )
    ```
- ### 跨域的常用实现方式
    - JSONP
    - CORS

## 9-6 ajax的常用插件
- ### jQuery.ajax
    ```js
    $.ajax({
        type: 'post',  // 默认get
        contentType: 'application/json;charset=UTF-8',  // 请求的媒体类型
        url: '/api',
        data: JSON.stringify(list),  // 对象或值转换为 JSON 字符串
        success: function (data) {
            console.log(data)
        },
        error: function (err) {
            console.log(err)
        }
    })
    ```
- ### [Fetch](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch)
    ```js
    fetch('http://a.com/api')
        .then( response => response.json() )
        .then( myJSON => console.log(myJSON) )
    ```
    - 当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject， 即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。
    - `fetch` 兼容性 没有 `XMLHttpRequest` 兼容性好

- ### [Axios](http://www.axios-js.com/zh-cn/docs/)
    - Axios 是基于 XMLHttpRequest 的封装
    - 支持 Node.js 和 Borwser
    - 支持 Promise Api



# 第10章 JS-Web-API-存储【内容虽然不多，但不可不会】
```
- 题目
    - 描述 cookie、localStorage、sessionStorage 区别
```
```
- 知识点
    - cookie
    - localStorage 和 sessionStorage
```

## 10-1 cookie
- cookie 本身是用于浏览器和 server 通信的
- cookie 是最早被 “借用” 来做本地存储的
    - 因为 `localStorage` 和 `sessionStorage` 是在 HTML5 在2010年 才被提出来的
    - 在那之前，只有 cookie 能做本地存储
- 可用 `document.cookie = '..'` 来修改
    ```js
    document.cookie="username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/";
    ```
    **注意**：不能同时设置 多个 cookie，
    ```js
    → document.cookie = 'a=100; b=200' // 如果你尝试设置多个 cookie，只会保留第一个
    ← "a=100"
    ```
- 只要不清除cookie，或过期，cookie 都会存在。利用cookie的这种特性，就能用来做本地存储了

- Cookie API
    - Cookie API 非常难用，官方没有专用的API，都是靠 自己封装实现方法的
    ```js
    /**
    * 设置cookie
    * @param {string} name  键名
    * @param {string} value 键值
    * @param {integer} days cookie周期
    */
    function setCookie(name,value,days) {
        if (days) {
            var date = new Date();
            date.setTime(date.getTime()+(days*24*60*60*1000));
            var expires = "; expires="+date.toGMTString();
        }else{
            var expires = "";
        }
        document.cookie = name+"="+value+expires+"; path=/";
    }
    // 获取cookie
    function getCookie(name) {
        var nameEQ = name + "=";
        var ca = document.cookie.split(';');
        for(var i=0;i < ca.length;i++) {
            var c = ca[i];
            while (c.charAt(0)==' ') c = c.substring(1,c.length);
            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
        }
        return null;
    }
    // 删除cookie
    function deleteCookie(name) {
        setCookie(name,"",-1);
    }
    ```
    
- ### cookie 的缺点
    - 存储大小，最大4kb
    - http请求时，需要发送到服务端，增加请求数据量
    - `document.cookie = '...'` 这种 api 来修改，太过简陋

- ### [cookie 是怎么工作的？](https://segmentfault.com/a/1190000004556040)
    - 首先必须明确一点，存储<code>cookie</code>是浏览器提供的功能。<code>cookie</code> 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 cookie 文件夹来存放各个域下设置的<code>cookie</code>。

    - 当网页要发<code>http</code>请求时，浏览器会先检查是否有相应的<code>cookie</code>，有则自动添加在<code>request header</code>中的<code>cookie</code>字段中。这些是浏览器自动帮我们做的，而且每一次<code>http</code>请求浏览器都会自动帮我们做。这个特点很重要，因为这关系到“什么样的数据适合存储在<code>cookie</code>中”。

    - 存储在<code>cookie</code>中的数据，每次都会被浏览器 **`自动放`** 在<code>http</code>请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销；但如果这些数据是每个请求都需要发给服务端的数据（比如身份认证信息），浏览器这设置自动处理就大大免去了重复添加操作。所以对于那设置“每次请求都要携带的信息（最典型的就是身份认证信息）”就特别适合放在<code>cookie</code>中，其他类型的数据就不适合了。

    - 但在 localStorage 出现之前，<code>cookie</code>被滥用当做了存储工具。什么数据都放在<code>cookie</code>中，即使这些数据只在页面中使用而不需要随请求传送到服务端。当然<code>cookie</code>标准还是做了一些限制的：每个域名下的cookie 的大小最大为4KB，每个域名下的<code>cookie</code>数量最多为20个（但很多浏览器厂商在具体实现时支持大于20个）。

<br><br>

## 10-2 html5存储 Storage
- localStorage 和 sessionStorage
    - HTML5 专门为存储而设计，最大可存5M
    - API 更简单易用 `setItem()` `getItem`
    - 不会随着 http 请求被发送出去

- localStorage 和 sessionStorage 的区别
    - localStorage 数据会永久储存，除非代码或手动删除
    - sessionStorage 数据只存在于当前会话，浏览器关闭则清空
    - 一般用 localStorage 会更多一些

- API
    ```js
    localStorage.setItem('mycat', 'tom')
    localStorage.getItem('mycat')
    localStorage.removeItem('mycat')
    localStorage.clear() // 清除所有 (本域名下)
    ```
    ```js
    sessionStorage.setItem('key', 'value')
    sessionStorage.getItem('key')
    sessionStorage.removeItem('key')
    sessionStorage.clear()
    ```
- 描述 `cookie` `localStorage` `sessionStorage` 的区别
    - 容量
    - api 易用性
        - `cookie` 没有官方统一 api，都是靠 自定义方法 来实现增删查改的
        - `Storage` 有官方统一 API
    - 是否跟随 http 请求发送出去
        - `cookie` 每次都会被浏览器 **`自动放在`** http 请求中发送出去
        - `Storage` 则不会

- ### sessionStorage生命周期
    - sessionStorage的清除时机是在会话结束，会话结束是在用户关闭标签页或者关闭窗口的时候；手动新开一个标签或窗口时，会新开会话，即使链接一样，也不会共享sessionStorage

    - 只有在下面情况1的时候，新开页面才能'共享'sessionStorage

        - 场景1: 如果用户在A页面下存储了test，通过js或者a标签跳转到同源的B页面时，A页面下的sessionStorage会被拷贝到B页面下，AB页面的sessionStorage虽然相同，但二者相互独立;

        - 场景2: 如果用户在A页面打开的情况下，手动打开了一个新标签页，访问A页面，此时会重开一个新回话，二者sessionStorage是不共享的。



# 第11章 开发环境【不会这些，你就会被认定是菜鸟小白，没做过项目】
## 11-1 关于开发环境
- 面试官想通过开发环境，了解候选人的实际工作情况
- 开发环境的工具，能体现工作产出效率
- 会以聊天形式为主，不会问具体问题？


## 11-2 git介绍
## 11-3 git命令介绍
## 11-4 git命令演示
## 11-5 chrome调试工具
## 11-6 抓包
- 抓包：主要解决 移动端、H5 的调试问题
    - 移动端、H5 在手机上，不像电脑端的浏览器  自带调试工具
    - 如果在 H5 上出现问题，如何查看数据获取情况、网络请求？

> <br>

> - windows 上一般用 **`fiddler`**
> - mac OS 一般用 **`charles`**
> <br>
<br>

- 步骤
    - 手机电脑 必须连同一个局域网
    - 将手机代理 到电脑上
    - 手机浏览网页，即可抓包

- 抓包工具内 ( fiddler / charles )
    - 查看网络请求
    - 网址代理
    - https

- [Fiddler网络抓包软件基础安装使用教程 【YouTube】](https://www.youtube.com/watch?v=sRAf_ILFFs0)
- [【it work !】如何使用远程调试在Chrome for iOS中调试问题](https://jonsadka.com/blog/how-to-debug-a-chrome-specific-bug-on-ios-using-remote-debugging/)


## 11-7 webpack-搭建环境
- 为什么需要 webpack babel ？
    - ES6 模块化，浏览器暂时不支持
    - ES6 (ES7, ES8) 语法 浏览器并不完全支持，需要转译成 ES5
    - 压缩代码，整合代码，以让网页加载更快

> 以下 webpack 代码，都是基于 webpack 4.x 版本的
- webpack 搭建项目步骤
    ```js
    npm init -y  // 初始化
    ```
    - 新建 `/src/index.js` 文件夹 和 文件
        ```js
        // /src/index.js
        console.log('hello webpack')
        ```
    - 新建 webpack配置文件 `webpack.config.js`
    ```js
    // /webpack.config.js
    const path = require('path')

    module.exports = {
        mode: 'production', // development
        entry: path.join(__dirname, 'src', 'index.js'),
        output: {
            filename: 'bundle.js',
            path: path.join(__dirname, 'dist')
        },
    }
    ```
    - 指定 打包时 的配置文件
        ```js
        // /package.json
        {
            "scripts": {
                "build": "webpack --config webpack.config.js"
            }
        }
        ```
    - 执行 打包命令
        ```
        webpack      // 全局安装时 打包命令
        npx webpack  // 局部安装时 打包命令
        ```
    - 安装两个插件
        - `html-webpack-plugin` html 处理插件
        - `webpack-dev-server` 启动本地服务插件
    ```js
    // /webpack.config.js
    const path = require('path')
    const HtmlWebpackPlugin = require('html-webpack-plugin')

    module.exports = {
        mode: 'development',
        entry: {
            main: path.join(__dirname, 'src', 'index.js')
        },
        output: {
            filename: '[name].bundle.js',
            path: path.join(__dirname, 'dist')
        },
        devServer: {
            port: 3000,
            contentBase: path.join(__dirname, 'dist'),
            open: true
        },
        plugins: [
            new HtmlWebpackPlugin({
                template: path.join(__dirname, '/src/index.html')
            })
        ]
    }
    ```
    ```js
    // /package.json
    {
        "scripts": {
            "build": "webpack --config webpack.config.js",
            "dev": "webpack-dev-server"
        }
    }
    ```
    - 3.执行脚本 `npm run dev` 或者 `npx webpack-dev-server`
    
## 11-8 webpack-babel
- `npm install --save-dev babel-loader @babel/core @babel/preset-env`
- 根目录下新建文件 `.babelrc`
    ```js
    // /.babelrc
    {
        "presets": ["@babel/preset-env"]  // preset-env 是很多插件 配置的集合，我们这里 直接使用这个 配置 就可以了
    }
    ```
    ```js
    // /webpack.config.js
    const path = require('path')
    const HtmlWebpackPlugin = require('html-webpack-plugin')

    module.exports = {
        mode: 'development',
        entry: {
            main: path.join(__dirname, 'src', 'index.js')
        },
        output: {
            filename: '[name].bundle.js',
            path: path.join(__dirname, 'dist')
        },
        devServer: {
            port: 3000,
            contentBase: path.join(__dirname, 'dist'),
            open: true
        },
        module: {
            rules: [
                {
                    test: /\.js$/,
                    loader: ['babel-loader'],
                    include: path.join(__dirname, 'src'),
                    exclude: /node_modules/
                }
            ]
        },
        plugins: [
            new HtmlWebpackPlugin({
                template: path.join(__dirname, '/src/index.html')
            })
        ]
    }
    ```
- 测试用例
    ```js
    const a = () => {
        console.log('babel is work!')
    }
    ```
    - 执行打包命令，看看 ES6 箭头函数 是否能够转译成 普通函数


## 11-9 webpack-ES6-Module
- ### 1.单个导出
    ```js
    // /a.js
    export function fn () {
        console.log('fn')
    }

    export const name = 'a'
    export const obj = {
        name: 'nick'
    }
    ```
    - 引用
        ```js
        import { fn, name, obj } from './a.js'  // ES6 解构赋值 语法

        fn()
        console.log(name)
        console.log(obj)
        ```
- ### 2.批量导出
    ```js
    // /a.js
    function fn () {
        console.log('fn')
    }

    const name = 'a'
    const obj = {
        name: 'nick'
    }

    // 批量导出
    export {
        fn,
        name,
        obj
    }
    ```
- ### 3.默认导出`export default`
    - 如果想 不用 解构赋值 的方法来引入
    - 或者 只导出一个
    - 就可以用 `export default`
    ```js
    const obj = { name: 'this is export default' }

    export default obj
    ```
    ```js
    import module_name from './xxx'   // import 时 模块名 自定义

    console.log(module_name);
    ```

参考文章：[还傻傻分不清 module.exports 和 export default 吗？【掘金】](https://juejin.im/post/6844903955282165773)
- ESM（ECMA Script Modules）模块主要由两个命令构成：export 和 import。
    ```js
    暴露模块：export default {} , export {} , export function(){}

    引入模块：import {xxx} from 'path'

    // 如果想为输入的变量重新取一个名字，要使用as关键字，将输入的变量重命名
    import { foo as bar } from './test.js';
    ```
- Node.js 的模块
    - Node 采用的是 **`CommonJS`** 模块规范
    - 语法
    ```js
    暴露模块：module.exports = value 或 exports.xxx = value

    引入模块：require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径
    ```
- 其他模块化方案
    - AMD ， CMD ， UMD
    - 还有最早的 立即执行函数模块化
        ```js
        (function(){
            var count = 0
            return count
        })()
        ```


## 11-10 webpack-配置生产环境
- 先看dev环境的配置文件
    ```js
    // /webpack.dev.config.js
    const path = require('path')
    const HtmlWebpackPlugin = require('html-webpack-plugin')

    module.exports = {
        mode: 'development',
        entry: {
            main: path.join(__dirname, 'src', 'index.js')
        },
        output: {
            filename: '[name].bundle.js',
            path: path.join(__dirname, 'dist')
        },
        devServer: {
            port: 3000,
            contentBase: path.join(__dirname, 'dist'),
            open: true
        },
        module: {
            rules: [
                {
                    test: /\.js$/,
                    loader: ['babel-loader'],
                    include: path.join(__dirname, 'src'),
                    exclude: /node_modules/
                }
            ]
        },
        plugins: [
            new HtmlWebpackPlugin({
                template: path.join(__dirname, '/src/index.html')
            })
        ]
    }
    ```
- 生产环境 配置文件 修改步骤
    - 1.把 mode 改成 `production`
    - 2.把 devServer 去掉
    - 3.加 `contenthash`
        - `filename: '[name].bundle.[contenthash].js'`
    - 4.增加 `npm script`
        ```js
        {
            "scripts": {
                "build": "webpack --config webpack.prod.config.js"
            }
        }
        ```
    - 5.执行打包 `npm run build`

    ```js
    // /webpack.prod.config.js
    const path = require('path')
    const HtmlWebpackPlugin = require('html-webpack-plugin')

    module.exports = {
        mode: 'production',
        entry: {
            main: path.join(__dirname, 'src', 'index.js')
        },
        output: {
            filename: '[name].bundle.[contenthash].js',
            path: path.join(__dirname, 'dist')
        },
        module: {
            rules: [
                {
                    test: /\.js$/,
                    loader: ['babel-loader'],
                    include: path.join(__dirname, 'src'),
                    exclude: /node_modules/
                }
            ]
        },
        plugins: [
            new HtmlWebpackPlugin({
                template: path.join(__dirname, '/src/index.html')
            })
        ]
    }
    ```


    
## 11-11 linux常用命令

- 为什么要学 linux ？
    - 公司的线上机器一般都是 linux
    - 测试机也需要保持一致，用 linux
    - 测试机 或 线上机 出了问题，本地又不能复现，需要去排查
    >  如何链接服务器，如何在服务器编辑文件 （ vim 怎么用？）

- ### 常用命令
    ```shell
    ssh username@192.168.10.21  # 登陆
    
    cd dir # 进入某文件夹

    ls     # 查看文件 和 文件夹
    ls -a  # 查看所有文件. linux 下如 .babelrc 以点开头的文件，都是隐藏文件
    ll     # 查看 文件权限，以 list 列表的形式看文件

    rm -rf foldername       # 把指定文件夹下 所有东西 删除

    mv a.js b.js        # 文件重命名. a.js 改成 b.js
    mv a.js ../a.js     # 移动文件.  这里是把 a.js 移动到上一级目录中

    cp a.js a1.js       # 拷贝文件   这里把 a.js 拷贝，并命名为 a1.js

    touch d.js          # 新建文件

    cat a.js    # 查看文件内容
    head a.js   # 查看文件 开始部分内容
    tail a.js   # 查看文件 末尾部分内容

    grep "babel" a.js   # 文件内容查找  在a.js 中查找 指定字符
    ```
- ### vim vi 命令
    ```shell
    vi d.js             # vi 新建文件 并打开   还有一种新建文件的方式，就是 vi

    i       # 进入编辑模式
    Esc     # 退出当前模式
    :w      # 保存
    :q      # 退出
    :wq!    # 强制保存并退出

    vimtutor # vim 教程
    ```



# 第12章 运行环境【这些会了，你就可以飞了】
## 12-1 运行环境介绍
## 12-2 页面加载和渲染过程
## 12-3 页面加载和渲染-示例
## 12-4 页面加载和渲染-问题解答
## 12-5 性能优化-原则和方向
- 性能优化
    - 是一个 综合性问题，没有标准答案，但要求尽量全面
    - 某些细节问题可能会单独提问：手写防抖、节流
        - 看你用没用过
        - 考你 定时器的使用


- ### 性能优化原则
    - 多使用内存、缓存 或其它方法
    - 减少 CPU 计算量，减少网络加载耗时
    - 以上两种方法 **`适用于所有编程的性能优化 ———— 空间换时间`**

- ### 性能优化 从何入手？
    - 让加载更快
    - 让渲染更快
        - 没有无用功
        - 没有重复渲染、没有等待
        - 至少在同一时间内，让用户看到的更快，让用户感觉更快

- ### 让加载更快
    - 减少资源体积：压缩代码、压缩资源，gzip
    - 减少访问次数：合并代码，合并资源（雪碧图），SSR服务器端渲染，缓存
    - 使用更快的网络：CDN

- ### 让渲染更快
    - CSS 放 head , JS 放 body 最下面
    - JS 尽早开始执行，用 `COMContentLoaded` 触发
    - 懒加载 （图片懒加载，下拉加载更多）
    - 对 DOM 查询进行缓存，避免同一个 DOM 进行多次查询。（DOM操作 是非常耗费性能的）
    - 频繁 DOM 操作，合并到一起 再插入 DOM 结构
    - 节流 `throttle`，防抖 `debounce`

## 12-6 性能优化-示例
- ### 资源合并
    - 为什么要做 资源合并？
        - 如果有 3个文件，每个都是 3kb 大小。然后在加载文件的时候，每个文件都需要 发起 http 请求
        - 这时候，如果有一个 9kb 大小的文件，在加载的时候 只需要发起一次 http 请求。
        - 虽然这 3个 小文件 总的数据量是 9kb，跟 一个 9kb 大小的文件是一样的数据量
        - 但是，3个小文件，每次请求都需要 重新发起 http 请求，总共3次 http请求。而一个 9kb 文件，只需要一次 http 请求 就可以完成
        - 这种情况下，`加载一个 9kb文件` 远比 `分别加载 3个 3kb 的文件` 要快得多
        ```html
        // 分别加载3个文件
        <script src="a.js"></script>
        <script src="b.js"></script>
        <script src="c.js"></script>


        // 加载1个合并后的文件
        <script src="abc.js"></script>
        ```
    - 怎么合并资源？
        - 可以通过 webpack 打包的方式合并资源
        ```js
        // abc.js

        import a from a.js
        import b from b.js
        import c from c.js

        // 业务处理逻辑...
        ```
        - 执行打包后，就会生成 目标合并文件了

- ### 缓存
    - 缓存的工作原理
        - 静态文件 加 hash 后缀，根据文件内容计算 hash
        - 文件内容不变，则 hash 不变，则 文件名 url 不变
        - URL 和 文件 不变，则会自动触发 http 缓存机制，返回 304
    - 如何加 Hash
        - webpack 打包后的文件加 `contenthash`
        - 打包后 生成的文件自带 hash，如 `main.bundle.7b269eee0ddb0b0e0bf0.js`
        ```js
        // /webpack.prod.config.js
        const path = require('path')
        const HtmlWebpackPlugin = require('html-webpack-plugin')

        module.exports = {
            mode: 'production',
            entry: {
                main: path.join(__dirname, 'src', 'index.js')
            },
            output: {
                filename: '[name].bundle.[contenthash].js',
                path: path.join(__dirname, 'dist')
            },
            module: {
                rules: [
                    {
                        test: /\.js$/,
                        loader: ['babel-loader'],
                        include: path.join(__dirname, 'src'),
                        exclude: /node_modules/
                    }
                ]
            },
            plugins: [
                new HtmlWebpackPlugin({
                    template: path.join(__dirname, '/src/index.html')
                })
            ]
        }
        ```
- 使用 CDN

- ### SSR 服务端渲染
    - 服务端渲染：将网页和数据一起加载，一起渲染
    - 非SSR（前后端分离）：先加载网页，ajax 再加载数据，再渲染数据
    - 早先的 JSP、ASP、PHP  其实都属于 SSR，现在的 Vue React SSR

- ### 懒加载
    - 参考文章：[延迟加载(Lazyload)三种实现方式](https://zhuanlan.zhihu.com/p/25455672)
    - 页面加载 解析的时候，不需要 全部图片加载完
    - 等到需要用到的时候，再去加载
    ```html
    <img id='img1' scr='preview.jpg' data-realsrc='abc.jpg'>
    <script>
        let img = document.getElementById('img1')
        img.src = img.getAttribute('data-realsrc')
    </script>
    ```
    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Lazyload 1</title>
        <style>
            img {
            display: block;
            margin-bottom: 50px;
            height: 200px;
        }
        </style>
    </head>
    <body>
        <img src="images/loading.gif" data-src="images/1.png">
        <img src="images/loading.gif" data-src="images/2.png">
        <img src="images/loading.gif" data-src="images/3.png">
        <img src="images/loading.gif" data-src="images/4.png">
        <img src="images/loading.gif" data-src="images/5.png">
        <img src="images/loading.gif" data-src="images/6.png">
        <img src="images/loading.gif" data-src="images/7.png">
        <img src="images/loading.gif" data-src="images/8.png">
        <img src="images/loading.gif" data-src="images/9.png">
        <img src="images/loading.gif" data-src="images/10.png">
        <img src="images/loading.gif" data-src="images/11.png">
        <img src="images/loading.gif" data-src="images/12.png">
        <script>
            function lazyload() {
                var images = document.getElementsByTagName('img');
                var len = images.length;
                var n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历		
                return function () {
                    var seeHeight = document.documentElement.clientHeight;
                    var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
                    for (var i = n; i < len; i++) {
                        if (images[i].offsetTop < seeHeight + scrollTop) {
                            if (images[i].getAttribute('src') === 'images/loading.gif') {
                                images[i].src = images[i].getAttribute('data-src');
                            }
                            n = n + 1;
                        }
                    }
                }
            }
            var loadImages = lazyload();
            loadImages(); //初始化首页的页面图片
            window.addEventListener('scroll', loadImages, false);
        </script>
    </body>
    </html>
    ```

## 12-7 性能优化-防抖debounce
## 12-8 性能优化-节流throttle
## 12-9 安全-xss
## 12-10 安全-xsrf
## 12-11 运行环境总结

------

明天从这里继续 9-3 9:35

# 第13章 课程总结【很有必要带你避免面试犯低级错误】
## 13-1 课程总结
## 13-2 面试技巧


# 第14章 真题模拟【我是来告诉你答案是什么】
## 14-1 章节介绍
## 
## 
----

# 异步编程
- 异步编程前言，为什么会出现异步编程？：[《阮一峰异步编程》](http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html)
    - "异步模式"编程的4种实现方法
        - 一、回调函数
        - 二、事件监听
        - 三、发布/订阅
        - 四、Promises对象
    - [JS 异步解决方案的发展历程以及优缺点](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/11)


----
